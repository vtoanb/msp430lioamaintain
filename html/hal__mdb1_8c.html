<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Zigbee Module Examples: HAL/hal_mdb1.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Module Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d2c8373d15d2dccc509742e7e07c05d9.html">HAL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hal_mdb1.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Hardware Abstraction Layer (HAL) for the Module Development Board 1 (MDB1). This development board has an MSP430F248 and module and was the initial development platform for these examples. This driver file is old and may not be compatible with all module examples. It is included herein as a reference and is included to show how easy it is to port the libraries to a different hardware platform. It also supports the UART interface to the module.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="hal__mdb1_8h.html">hal_mdb1.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hal__msp430x2xxx__oscillators_8h.html">hal_msp430x2xxx_oscillators.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hal__msp430x2xxx__usci_8h.html">hal_msp430x2xxx_usci.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6c7083f0131c4c7a3bbfeb0a3e2a90ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7083f0131c4c7a3bbfeb0a3e2a90ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EXCLUDE_STATUS_LEDS</b>&#160;&#160;&#160;0x3F</td></tr>
<tr class="memitem:a848a94a66500eaa5493f9a235bd8a3dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a848a94a66500eaa5493f9a235bd8a3dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>TIMER_MAX_SECONDS</b>&#160;&#160;&#160;4</td></tr>
<tr class="memitem:a4f03ab5d527a13ad423e874f2c628a2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f03ab5d527a13ad423e874f2c628a2f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADC_VREF_DELAY_MS</b>&#160;&#160;&#160;17</td></tr>
<tr class="memitem:a0da47ce90529abfb4a603ab1af089546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0da47ce90529abfb4a603ab1af089546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADC12_COUNT_TO_MILLIVOLT_MULTIPLIER_3V3</b>&#160;&#160;&#160;1.220703125</td></tr>
<tr class="memitem:a247a569bdbcb2ec613831cf4562a090b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a247a569bdbcb2ec613831cf4562a090b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ADC_COUNT_TO_VCC_UNREG_MULTIPLIER</b>&#160;&#160;&#160;6.715506715506716f</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1c27b12dfd9998dbc915bee092a83447"><td class="memItemLeft" align="right" valign="top">__interrupt void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a1c27b12dfd9998dbc915bee092a83447">USCIAB0RX_ISR</a> (void)</td></tr>
<tr class="memitem:af08d888a69d655969bf7b79612847c95"><td class="memItemLeft" align="right" valign="top">__interrupt void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#af08d888a69d655969bf7b79612847c95">USCI1RX_ISR</a> (void)</td></tr>
<tr class="memitem:ae9ce04c109f0c34da1b84091547ddea6"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ae9ce04c109f0c34da1b84091547ddea6">getButtons</a> ()</td></tr>
<tr class="memitem:a6ddfaf32b7620184897c858c576dc5a3"><td class="memItemLeft" align="right" valign="top">__interrupt void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a6ddfaf32b7620184897c858c576dc5a3">PORT2_ISR</a> (void)</td></tr>
<tr class="memitem:a30a6a305ab51297fa0e5020249726b20"><td class="memItemLeft" align="right" valign="top">__interrupt void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a30a6a305ab51297fa0e5020249726b20">PORT1_ISR</a> (void)</td></tr>
<tr class="memitem:a555c96f2449b1a7cbb4c9a799319c0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a555c96f2449b1a7cbb4c9a799319c0e3">doNothing</a> (int8_t a)</td></tr>
<tr class="memitem:a36b1f5df38495d059d4e1c541879b8ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a36b1f5df38495d059d4e1c541879b8ad">oscInit</a> ()</td></tr>
<tr class="memitem:a8169743b200bc535b882a5dd7244ebcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8169743b200bc535b882a5dd7244ebcb">halEnableAuxFlowControl</a> ()</td></tr>
<tr class="memitem:a88989ee5b8e22c8824a6998cebeb41ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a88989ee5b8e22c8824a6998cebeb41ce">portInit</a> ()</td></tr>
<tr class="memitem:abc6c00d8d65f1bed6f2ce307998dada0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#abc6c00d8d65f1bed6f2ce307998dada0">halInit</a> ()</td></tr>
<tr class="memitem:af4de2514b7778805db3815e8dd6cf09a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#af4de2514b7778805db3815e8dd6cf09a">putchar</a> (int c)</td></tr>
<tr class="memitem:a307cb2e2f71f62b5717971c0743184c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a307cb2e2f71f62b5717971c0743184c5">putcharAux</a> (int c)</td></tr>
<tr class="memitem:aa49deef93c419ac4ff610d37400b2ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aa49deef93c419ac4ff610d37400b2ee1">delayMs</a> (unsigned int delay)</td></tr>
<tr class="memitem:a3d8659694ed715ee324a4d3ed39b36f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a3d8659694ed715ee324a4d3ed39b36f8">halSpiInitModule</a> ()</td></tr>
<tr class="memitem:a8653a168989b0498a6bbfe865150d58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8653a168989b0498a6bbfe865150d58c">spiWrite</a> (unsigned char *bytes, unsigned char numBytes)</td></tr>
<tr class="memitem:a9219220bab21b825b130b22bef861eb0"><td class="memItemLeft" align="right" valign="top">signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a9219220bab21b825b130b22bef861eb0">setStatusLed</a> (unsigned char color)</td></tr>
<tr class="memitem:a7f62c9b5ce14a0962bbf56e532a0a44f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a7f62c9b5ce14a0962bbf56e532a0a44f">setButtonLeds</a> (unsigned char led)</td></tr>
<tr class="memitem:a5a0c8f1d5aaf7c4ce53ad9af0fe110ec"><td class="memItemLeft" align="right" valign="top">signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a5a0c8f1d5aaf7c4ce53ad9af0fe110ec">setLed</a> (unsigned char led)</td></tr>
<tr class="memitem:a5801a13917aa5f680d836b0543c4100b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a5801a13917aa5f680d836b0543c4100b">clearLeds</a> ()</td></tr>
<tr class="memitem:a4c9b9a57a69edf4ef7d6a024ac5335d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a4c9b9a57a69edf4ef7d6a024ac5335d2">clearButtonLeds</a> ()</td></tr>
<tr class="memitem:a67f724ff9563f197e92725de1aa01e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a67f724ff9563f197e92725de1aa01e43">toggleLed</a> (unsigned char whichLed)</td></tr>
<tr class="memitem:a279999fb4ab7e68771046e6b14ef162e"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a279999fb4ab7e68771046e6b14ef162e">getSwitches</a> ()</td></tr>
<tr class="memitem:aa6f6bfef028c7b053444cbd48567d286"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aa6f6bfef028c7b053444cbd48567d286">stopTimer</a> ()</td></tr>
<tr class="memitem:abd56b9af5c5095f207b79b18e07c547c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd56b9af5c5095f207b79b18e07c547c"></a>
__interrupt void&#160;</td><td class="memItemRight" valign="bottom"><b>Timer_A0</b> (void)</td></tr>
<tr class="memitem:ae0e1e0c1a44a276132f333945b102968"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ae0e1e0c1a44a276132f333945b102968">initTimer</a> (uint8_t seconds)</td></tr>
<tr class="memitem:aea54cfa0b896d2e756d3eb75273a1710"><td class="memItemLeft" align="right" valign="top">signed int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aea54cfa0b896d2e756d3eb75273a1710">calibrateVlo</a> ()</td></tr>
<tr class="memitem:a7979965bb7ea3b7faf9fcbdde116fe7b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a7979965bb7ea3b7faf9fcbdde116fe7b">getVcc3</a> ()</td></tr>
<tr class="memitem:a19f1ac1fa47fb6383c2a899d2ff60462"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a19f1ac1fa47fb6383c2a899d2ff60462">getVddUnregulated</a> ()</td></tr>
<tr class="memitem:adcbde627c29a932b3c8a58b58f27f020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#adcbde627c29a932b3c8a58b58f27f020">halSetAllPinsToInputs</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8ea0277788bcfa3a8c78da5ae61abff4"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a8ea0277788bcfa3a8c78da5ae61abff4">debugConsoleIsr</a> )(int8_t)</td></tr>
<tr class="memitem:ac788093c014413b5b43a115745bc6d29"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ac788093c014413b5b43a115745bc6d29">buttonIsr</a> )(int8_t)</td></tr>
<tr class="memitem:a3c45efda7c559068f1d026b79c36e5c5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a3c45efda7c559068f1d026b79c36e5c5">auxSerialPort</a> )(char)</td></tr>
<tr class="memitem:ace9761ce5b6f8de452f5ee43a28d6e87"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#ace9761ce5b6f8de452f5ee43a28d6e87">bitBangSerialIsr</a> )(char)</td></tr>
<tr class="memitem:acd982f0226c803dec387c98b2c033e84"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#acd982f0226c803dec387c98b2c033e84">wakeupFlags</a> = 0</td></tr>
<tr class="memitem:a192b1c65dd338966842225b5afcdff84"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#a192b1c65dd338966842225b5afcdff84">vloFrequency</a> = 0</td></tr>
<tr class="memitem:aaf9761c8fd3f159f938f5ad2c68633a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aaf9761c8fd3f159f938f5ad2c68633a7">aClk</a> = 0</td></tr>
<tr class="memitem:aaf473d7d866976957729b47a5554a4ad"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hal__mdb1_8c.html#aaf473d7d866976957729b47a5554a4ad">timerIsr</a> )(void)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Hardware Abstraction Layer (HAL) for the Module Development Board 1 (MDB1). This development board has an MSP430F248 and module and was the initial development platform for these examples. This driver file is old and may not be compatible with all module examples. It is included herein as a reference and is included to show how easy it is to port the libraries to a different hardware platform. It also supports the UART interface to the module. </p>
<p>Peripherals:</p>
<ul>
<li>Module Interface: Connects to the module via jumper-selectable SPI or UART</li>
<li>LEDs: Six general purpose LEDs, one bi-color (Red/Yellow/Green) Status LED, and one power LED</li>
<li>Buttons: Five general purpose buttons, one reset button</li>
<li>Interfaces: MSP430 &amp; module programming connectors, RS-232 on DB-9</li>
<li>Crystals: External 32kHz and 16MHz crystal options</li>
<li>I2C Serial EEPROM</li>
<li>Other I/O: Two Opto-Isolated inputs, Four relay drivers, I/O pins on headers</li>
<li>Configurability: All on-board peripherals may be disabled with cuttable jumpers</li>
</ul>
<p>Module UART implementation configuration: </p>
<dl class="section note"><dt>Note:</dt><dd>CTS (Clear To Send) is an output of processor, input to Module<ul>
<li>CTS = 0: CC2530 will transmit</li>
<li>CTS = 1: CC2530 will stop transmitting 1.0 Module CTS (if using serial), output 1.1 Module RTS (if using serial), input, no interrupt 1.2 Module Reset (used either Module interface is SPI or UART) 1.3 Module SRDY (only used if Module interface is SPI) 3.6 Second (Module/Aux) UART Tx (used if Module interface is UART) 3.7 Second (Module/Aux) UART Rx (used if Module interface is UART)</li>
</ul>
</dd></dl>
<dl class="section rcs"><dt>Rev:</dt><dd>1765 </dd></dl>
<dl class="section rcs"><dt>Author:</dt><dd>dsmith </dd></dl>
<dl class="section rcs"><dt>Date:</dt><dd>2013-03-07 14:51:02 -0800 (Thu, 07 Mar 2013) </dd></dl>
<h1><a class="anchor" id="support"></a>
Support</h1>
<p>Please refer to the wiki at www.anaren.com/air-wiki-zigbee for more information. Additional support is available via email at the following addresses:</p>
<ul>
<li>Questions on how to use the product: <a href="#" onclick="location.href='mai'+'lto:'+'AIR'+'@a'+'nar'+'en'+'.co'+'m'; return false;">AIR@a<span style="display: none;">.nosp@m.</span>nare<span style="display: none;">.nosp@m.</span>n.com</a></li>
<li>Feature requests, comments, and improvements: <a href="#" onclick="location.href='mai'+'lto:'+'fea'+'tu'+'rer'+'eq'+'ues'+'ts'+'@te'+'sl'+'aco'+'nt'+'rol'+'s.'+'com'; return false;">featu<span style="display: none;">.nosp@m.</span>rere<span style="display: none;">.nosp@m.</span>quest<span style="display: none;">.nosp@m.</span>s@te<span style="display: none;">.nosp@m.</span>slaco<span style="display: none;">.nosp@m.</span>ntro<span style="display: none;">.nosp@m.</span>ls.co<span style="display: none;">.nosp@m.</span>m</a></li>
<li>Consulting engagements: <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@te'+'sl'+'aco'+'nt'+'rol'+'s.'+'com'; return false;">sales<span style="display: none;">.nosp@m.</span>@tes<span style="display: none;">.nosp@m.</span>lacon<span style="display: none;">.nosp@m.</span>trol<span style="display: none;">.nosp@m.</span>s.com</a></li>
</ul>
<h1><a class="anchor" id="license"></a>
License</h1>
<p>Copyright (c) 2012 Tesla Controls. All rights reserved. This Software may only be used with an Anaren A2530E24AZ1, A2530E24CZ1, A2530R24AZ1, or A2530R24CZ1 module. Redistribution and use in source and binary forms, with or without modification, are subject to the Software License Agreement in the file "anaren_eula.txt"</p>
<p>YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL ANAREN MICROWAVE OR TESLA CONTROLS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSE INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="aea54cfa0b896d2e756d3eb75273a1710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int calibrateVlo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Required for compatibility with MSP430 libraries</p>
<p>Calibrate VLO. Once this is done, the VLO can be used semi-accurately for timers etc. Once calibrated, VLO is within ~2% of actual when using a 1% calibrated DCO frequency and temperature and supply voltage remain unchanged. </p>
<dl class="section return"><dt>Returns:</dt><dd>VLO frequency (number of VLO counts in 1sec), or -1 if out of range </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>SMCLK is 4MHz </dd>
<dd>
MCLK is 8MHz </dd>
<dd>
ACLK sourced by VLO (BCSCTL3 = LFXT1S_2 in MSP430F2xxx) </dd></dl>
<dl class="section note"><dt>Note:</dt><dd>Calibration is only as good as MCLK source. Obviously, if using the internal DCO (+/- 1%) then this value will only be as good as +/- 1%. YMMV. </dd>
<dd>
On MSP430F248 or MSP430F22x2 or MSP430F22x4, must use TACCR2. On MSP430F20x2, must use TACCR0. On MSP430G2553, must use CCI0B on CCR0 Check device-specific datasheet to see which module block has ACLK as a compare input. Modify TACCTLx, TACCRx, and CCIS_x accordingly For example, see page 23 of the MSP430F24x datasheet or page 17 of the MSP430F20x2 datasheet, or page 18 of the MSP430F22x4 datasheet. </dd>
<dd>
If application will require accuracy over change in temperature or supply voltage, recommend calibrating VLO more often. </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>Timer A settings restored to what they were beforehand except for TACCR0 which is reset. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c9b9a57a69edf4ef7d6a024ac5335d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearButtonLeds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns off the button LEDs and leaves status LED unchanged. </p>
<dl class="section post"><dt>Postcondition:</dt><dd>button LEDs are all off. Status LED is in the same state as it was before the method was called. </dd></dl>

</div>
</div>
<a class="anchor" id="a5801a13917aa5f680d836b0543c4100b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearLeds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns OFF the specified LED. Required for Module examples. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">led</td><td>the LED to turn off, must be 0,1,2,3,4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="aa49deef93c419ac4ff610d37400b2ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delayMs </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A fairly accurate blocking delay for waits in the millisecond range. Good for 1mSec to 1000mSec. At 1MHz, error of zero for 100mSec or 1000mSec. For 10mSec, error of 100uSec. At 1mSec, error is 20uSec. At 8MHz, error of zero for 1000mSec. Note that accuracy will depend on the clock source. MSP430F2xx internal DCO is typically +/-1%. For better timing accuracy, use a timer, or a crystal. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>TICKS_IN_ONE_MS is defined correctly </dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>number of milliseconds to delay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a555c96f2449b1a7cbb4c9a799319c0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void doNothing </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple placeholder to point the function pointers to so that they don't cause mischief </p>

</div>
</div>
<a class="anchor" id="ae9ce04c109f0c34da1b84091547ddea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char getButtons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the current status of the buttons </p>
<dl class="section return"><dt>Returns:</dt><dd>0x01 if button 1 is pressed, 0x02 if button 2 is pressed, 0x04 if button 3 is pressed, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="a279999fb4ab7e68771046e6b14ef162e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char getSwitches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read value of the two Dual In-Line Package (DIP) switches. </p>
<dl class="section return"><dt>Returns:</dt><dd>the state of the switches as a number from 0 to 3. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>DIP Switches (P2.6, P2.7) are configured as digital inputs with pull-DOWNs </dd></dl>

</div>
</div>
<a class="anchor" id="a7979965bb7ea3b7faf9fcbdde116fe7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getVcc3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures Vcc to the MSP430, nominally 3300mV on the MDB1</p>
<ul>
<li>ADC measures VCC/2 compared to 2.5V reference</li>
<li>If Vcc = 3.3V, ADC output should be (1.65/2.5)*4095 = 2703</li>
<li>(halfVcc/2.5)*4095 = ADC reading and (Vcc/2.5)*4095 = 2*ADC</li>
<li>Vcc*4096 = 5*ADC &ndash;&gt; and VCC=5*ADC/4095 <dl class="section return"><dt>Returns:</dt><dd>Vcc in millivolts </dd></dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a19f1ac1fa47fb6383c2a899d2ff60462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int getVddUnregulated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Measures Unregulated input voltage. This feeds a 10k/1k 1% resistor divider to the MSP430 ADC input A3.</p>
<ul>
<li>ADC measures VCC/11 compared to 2.5V reference</li>
<li>If VddUnregulated = 8V, ADC output should be (0.727/2.5)*4095 = 1191</li>
<li>(eleventh8V8/2.5)*4095 = ADC reading and (8V8/2.5)*4095 = 11*ADC</li>
<li>Vcc*4096 = 27.5*ADC &ndash;&gt; and VCC=27.5*ADC/4095</li>
<li>V = 8 then Vccunreg/11 = 0.801, or 2187 adc counts if using 1.5V reference</li>
</ul>
<dl class="section return"><dt>Returns:</dt><dd>Vdd Unregulated in millivolts </dd></dl>

</div>
</div>
<a class="anchor" id="a8169743b200bc535b882a5dd7244ebcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halEnableAuxFlowControl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables flow control (makes the pin an output) and enables communications to occur. </p>

</div>
</div>
<a class="anchor" id="abc6c00d8d65f1bed6f2ce307998dada0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures hardware for the particular board</p>
<ul>
<li>Initializes clocks</li>
<li>Ports: including purpose, direction, pullup/pulldown resistors etc.</li>
<li>Holds radio in reset (active-low) </li>
</ul>

</div>
</div>
<a class="anchor" id="adcbde627c29a932b3c8a58b58f27f020"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halSetAllPinsToInputs </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures all module interface signals as inputs to allow the module to be programmed. Toggles LED0 quickly to indicate application is running. </p>

</div>
</div>
<a class="anchor" id="a3d8659694ed715ee324a4d3ed39b36f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halSpiInitModule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the SPI interface to the Module. </p>
<dl class="section note"><dt>Note:</dt><dd>Module SPI clock speed &lt; 4MHz. SPI port configured for clock polarity of 0, clock phase of 0, and MSB first. </dd>
<dd>
On MDB the RFIC SPI port is USCIB1 </dd>
<dd>
Modify this method for other hardware implementations. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>SPI pins configured correctly: Clock, MOSI, MISO configured as SPI function; Chip Select configured as an output; SRDY configured as an input. </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>SPI port is configured for RFIC communications. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e1e0c1a44a276132f333945b102968"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t initTimer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures timer. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>ACLK sourced from VLO </dd>
<dd>
VLO has been calibrated; number of VLO counts in one second is in vloFrequency. </dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>period of the timer. Maximum is 0xFFFF / vloFrequency; or about 4 since VLO varies between 9kHz - 15kHz. Use a prescaler on timer (e.g. set IDx bits in TACTL register) for longer times. Maximum prescaling of Timer A is divide by 8. Even longer times can be obtained by prescaling ACLK if this doesn't affect other system peripherals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>0 if success; -1 if illegal parameter or -2 if VLO not calibrated </dd></dl>

</div>
</div>
<a class="anchor" id="a36b1f5df38495d059d4e1c541879b8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void oscInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initializes Oscillator
</pre><ul>
<li>turns off WDT</li>
<li>Configures MCLK to 8MHz using internal DCO</li>
<li>Sets SMCLK to 4MHz</li>
<li>Configures ACLK to use external xtal. </li>
</ul>

</div>
</div>
<a class="anchor" id="a30a6a305ab51297fa0e5020249726b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void PORT1_ISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Port P1 interrupt service routine. 
</pre> <dl class="section pre"><dt>Precondition:</dt><dd>Port 1 pins are configured as interrupts appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ddfaf32b7620184897c858c576dc5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void PORT2_ISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Port P2 interrupt service routine. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>Port 2 pins are configured as interrupts appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="a88989ee5b8e22c8824a6998cebeb41ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void portInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes Ports/Pins: sets direction, interrupts, pullup/pulldown resistors etc. </p>

</div>
</div>
<a class="anchor" id="af4de2514b7778805db3815e8dd6cf09a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putchar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send one byte via hardware UART. Called by printf() etc. in stdio.h </p>

</div>
</div>
<a class="anchor" id="a307cb2e2f71f62b5717971c0743184c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int putcharAux </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send one byte via hardware UART to the auxilliary serial port. Aux Serial Port is USCIA1. </p>

</div>
</div>
<a class="anchor" id="a7f62c9b5ce14a0962bbf56e532a0a44f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setButtonLeds </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>led</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns on the specified button LED. Leaves status LED unchanged. </p>
<dl class="section note"><dt>Note:</dt><dd>Button LEDs are active-LOW, Status LED is active-HIGH. </dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichLed</td><td>the LED to turn on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a0c8f1d5aaf7c4ce53ad9af0fe110ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed int setLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>led</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns ON the specified LED. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">led</td><td>the LED to turn on, must be 0,1,2,3,4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>0 if success, -1 if invalid LED specified </dd></dl>

</div>
</div>
<a class="anchor" id="a9219220bab21b825b130b22bef861eb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">signed char setStatusLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LED Control Sets the status LED to a particular color. Leaves the other LEDs unchanged. The status LED is a two-element LED (red+green) that is capable of displaying red, green, or yellow. </p>
<dl class="section note"><dt>Note:</dt><dd>Button LEDs are active-LOW, Status LED is active-HIGH. </dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>the color to set, must be STATUS_LED_RED, STATUS_LED_GREEN, or STATUS_LED_YELLOW. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>-1 if invalid color, 0 if success </dd></dl>

</div>
</div>
<a class="anchor" id="a8653a168989b0498a6bbfe865150d58c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiWrite </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to communicate with Zigbee module </p>

</div>
</div>
<a class="anchor" id="aa6f6bfef028c7b053444cbd48567d286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stopTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Halts the timer. Leaves period unchanged. </p>

</div>
</div>
<a class="anchor" id="a67f724ff9563f197e92725de1aa01e43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void toggleLed </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>whichLed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Toggles the specified button LED. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichLed</td><td>the LED to toggle, must be 0-4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition:</dt><dd>The specified button LED is toggled. Status LED is unchanged. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>this should read from a globals file based on the type of device, how many LEDs, etc. </dd></dl>

</div>
</div>
<a class="anchor" id="af08d888a69d655969bf7b79612847c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void USCI1RX_ISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxilliary Serial Port interrupt service routine, called when a byte is received on USCIA1 or USCIB1. </p>

</div>
</div>
<a class="anchor" id="a1c27b12dfd9998dbc915bee092a83447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__interrupt void USCIAB0RX_ISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debug console interrupt service routine, called when a byte is received on USCIA0 or USCIB0. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aaf9761c8fd3f159f938f5ad2c68633a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int aClk = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock speed of the auxilliary clock. Set in <a class="el" href="hal__ek-lm4f120_x_l_8c.html#a36b1f5df38495d059d4e1c541879b8ad">oscInit()</a> if an external xtal is used or <a class="el" href="hal__ek-lm4f120_x_l_8c.html#a14df2a9ef70dacfe536dca20da0c41b0">calibrateVlo()</a> if using VLO. </p>

</div>
</div>
<a class="anchor" id="a3c45efda7c559068f1d026b79c36e5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* auxSerialPort)(char)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer for the ISR called when a byte is received on the aux. serial port </p>

</div>
</div>
<a class="anchor" id="ace9761ce5b6f8de452f5ee43a28d6e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* bitBangSerialIsr)(char)</td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Function pointer for the ISR called when a byte is received on the bit-bang 
</pre><p> serial port. Parameter is which bit-bang interface (0 or 1) </p>

</div>
</div>
<a class="anchor" id="ac788093c014413b5b43a115745bc6d29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* buttonIsr)(int8_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer for the ISR called when a button is pressed. Parameter is which button. </p>

</div>
</div>
<a class="anchor" id="a8ea0277788bcfa3a8c78da5ae61abff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* debugConsoleIsr)(int8_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a function pointer for the Interrupt Service Routine called when a debug console character is received. To use it, declare it with <code> extern void (*debugConsoleIsr)(char); </code> and then point it to a function you created, e.g. <code> debugConsoleIsr =  </code> and your function <a class="el" href="example__network__explorer_8c.html#a380fc05105ca76598ce5f0d5337ce19c">handleDebugConsoleInterrupt()</a> will be called when a byte is received. </p>

</div>
</div>
<a class="anchor" id="aaf473d7d866976957729b47a5554a4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* timerIsr)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer for the ISR called when a timer generates an interrupt </p>

</div>
</div>
<a class="anchor" id="a192b1c65dd338966842225b5afcdff84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t vloFrequency = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The post-calibrated frequency of the Very Low Oscillator (VLO). This MUST be calibrated by <a class="el" href="hal__ek-lm4f120_x_l_8c.html#a14df2a9ef70dacfe536dca20da0c41b0">calibrateVlo()</a> prior to use. Set with <a class="el" href="hal__ek-lm4f120_x_l_8c.html#a14df2a9ef70dacfe536dca20da0c41b0">calibrateVlo()</a> and read by <a class="el" href="hal__ek-lm4f120_x_l_8c.html#ae0e1e0c1a44a276132f333945b102968">initTimer()</a>. </p>

</div>
</div>
<a class="anchor" id="acd982f0226c803dec387c98b2c033e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t wakeupFlags = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags to indicate when to wake up the processor. These are read in the various ISRs. If the flag is set then the processor will be woken up with HAL_WAKEUP() at the end of the ISR. This is required because HAL_WAKEUP() cannot be called anywhere except in an ISR. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 20 2014 15:34:13 for Zigbee Module Examples by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
