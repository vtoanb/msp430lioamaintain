<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Zigbee Module Examples: Flash_pb_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Module Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash_pb_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae9560b79ebc5c7d96bea3c0821a0373a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae9560b79ebc5c7d96bea3c0821a0373a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FLASH_SECTOR_SIZE</b>&#160;&#160;&#160;1024</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga23009e41efdcc6dcb32f936f1c3aff92"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__pb__api.html#ga23009e41efdcc6dcb32f936f1c3aff92">FlashPBGet</a> (void)</td></tr>
<tr class="memitem:ga0f202e339edf1758a8b484afa19fb074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__pb__api.html#ga0f202e339edf1758a8b484afa19fb074">FlashPBSave</a> (uint8_t *pui8Buffer)</td></tr>
<tr class="memitem:gae1026232dae81709cbe4f7b956749942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__pb__api.html#gae1026232dae81709cbe4f7b956749942">FlashPBInit</a> (uint32_t ui32Start, uint32_t ui32End, uint32_t ui32Size)</td></tr>
<tr class="memitem:ga2b0a5c468217d0bbe9fc759a25251ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__pb__api.html#ga2b0a5c468217d0bbe9fc759a25251ac6">FlashPBSave</a> (unsigned char *pucBuffer)</td></tr>
<tr class="memitem:ga62b91dae0908325100406d353233827c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flash__pb__api.html#ga62b91dae0908325100406d353233827c">FlashPBInit</a> (unsigned long ulStart, unsigned long ulEnd, unsigned long ulSize)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga23009e41efdcc6dcb32f936f1c3aff92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * FlashPBGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the address of the most recent parameter block.</p>
<p>This function returns the address of the most recent parameter block that is stored in flash.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the address of the most recent parameter block, or NULL if there are no valid parameter blocks in flash. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62b91dae0908325100406d353233827c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashPBInit </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the flash parameter block.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulStart</td><td>is the address of the flash memory to be used for storing flash parameter blocks; this must be the start of an erase block in the flash. </td></tr>
    <tr><td class="paramname">ulEnd</td><td>is the address of the end of flash memory to be used for storing flash parameter blocks; this must be the start of an erase block in the flash (the first block that is NOT part of the flash memory to be used), or the address of the first word after the flash array if the last block of flash is to be used. </td></tr>
    <tr><td class="paramname">ulSize</td><td>is the size of the parameter block when stored in flash; this must be a power of two less than or equal to the flash erase block size (typically 1024).</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes a fault-tolerant, persistent storage mechanism for a parameter block for an application. The last several erase blocks of flash (as specified by <em>ulStart</em> and <em>ulEnd</em> are used for the storage; more than one erase block is required in order to be fault-tolerant.</p>
<p>A parameter block is an array of bytes that contain the persistent parameters for the application. The only special requirement for the parameter block is that the first byte is a sequence number (explained in <a class="el" href="group__flash__pb__api.html#ga0f202e339edf1758a8b484afa19fb074">FlashPBSave()</a>) and the second byte is a checksum used to validate the correctness of the data (the checksum byte is the byte such that the sum of all bytes in the parameter block is zero).</p>
<p>The portion of flash for parameter block storage is split into N equal-sized regions, where each region is the size of a parameter block (<em>ulSize</em>). Each region is scanned to find the most recent valid parameter block. The region that has a valid checksum and has the highest sequence number (with special consideration given to wrapping back to zero) is considered to be the current parameter block.</p>
<p>In order to make this efficient and effective, three conditions must be met. The first is <em>ulStart</em> and <em>ulEnd</em> must be specified such that at least two erase blocks of flash are dedicated to parameter block storage. If not, fault tolerance can not be guaranteed since an erase of a single block will leave a window where there are no valid parameter blocks in flash. The second condition is that the size (<em>ulSize</em>) of the parameter block must be an integral divisor of the size of an erase block of flash. If not, a parameter block will end up spanning between two erase blocks of flash, making it more difficult to manage. The final condition is that the size of the flash dedicated to parameter blocks (<em>ulEnd</em> - <em>ulStart</em>) divided by the parameter block size (<em>ulSize</em>) must be less than or equal to 128. If not, it will not be possible in all cases to determine which parameter block is the most recent (specifically when dealing with the sequence number wrapping back to zero).</p>
<p>When the microcontroller is initially programmed, the flash blocks used for parameter block storage are left in an erased state.</p>
<p>This function must be called before any other flash parameter block functions are called.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1026232dae81709cbe4f7b956749942"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashPBInit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the flash parameter block.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Start</td><td>is the address of the flash memory to be used for storing flash parameter blocks; this must be the start of an erase block in the flash. </td></tr>
    <tr><td class="paramname">ui32End</td><td>is the address of the end of flash memory to be used for storing flash parameter blocks; this must be the start of an erase block in the flash (the first block that is NOT part of the flash memory to be used), or the address of the first word after the flash array if the last block of flash is to be used. </td></tr>
    <tr><td class="paramname">ui32Size</td><td>is the size of the parameter block when stored in flash; this must be a power of two less than or equal to the flash erase block size (typically 1024).</td></tr>
  </table>
  </dd>
</dl>
<p>This function initializes a fault-tolerant, persistent storage mechanism for a parameter block for an application. The last several erase blocks of flash (as specified by <em>ui32Start</em> and <em>ui32End</em> are used for the storage; more than one erase block is required in order to be fault-tolerant.</p>
<p>A parameter block is an array of bytes that contain the persistent parameters for the application. The only special requirement for the parameter block is that the first byte is a sequence number (explained in <a class="el" href="group__flash__pb__api.html#ga0f202e339edf1758a8b484afa19fb074">FlashPBSave()</a>) and the second byte is a checksum used to validate the correctness of the data (the checksum byte is the byte such that the sum of all bytes in the parameter block is zero).</p>
<p>The portion of flash for parameter block storage is split into N equal-sized regions, where each region is the size of a parameter block (<em>ui32Size</em>). Each region is scanned to find the most recent valid parameter block. The region that has a valid checksum and has the highest sequence number (with special consideration given to wrapping back to zero) is considered to be the current parameter block.</p>
<p>In order to make this efficient and effective, three conditions must be met. The first is <em>ui32Start</em> and <em>ui32End</em> must be specified such that at least two erase blocks of flash are dedicated to parameter block storage. If not, fault tolerance can not be guaranteed since an erase of a single block will leave a window where there are no valid parameter blocks in flash. The second condition is that the size (<em>ui32Size</em>) of the parameter block must be an integral divisor of the size of an erase block of flash. If not, a parameter block will end up spanning between two erase blocks of flash, making it more difficult to manage. The final condition is that the size of the flash dedicated to parameter blocks (<em>ui32End</em> - <em>ui32Start</em>) divided by the parameter block size (<em>ui32Size</em>) must be less than or equal to 128. If not, it will not be possible in all cases to determine which parameter block is the most recent (specifically when dealing with the sequence number wrapping back to zero).</p>
<p>When the microcontroller is initially programmed, the flash blocks used for parameter block storage are left in an erased state.</p>
<p>This function must be called before any other flash parameter block functions are called.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b0a5c468217d0bbe9fc759a25251ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashPBSave </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucBuffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a new parameter block to flash.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucBuffer</td><td>is the address of the parameter block to be written to flash.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will write a parameter block to flash. Saving the new parameter blocks involves three steps:</p>
<ul>
<li>Setting the sequence number such that it is one greater than the sequence number of the latest parameter block in flash.</li>
<li>Computing the checksum of the parameter block.</li>
<li>Writing the parameter block into the storage immediately following the latest parameter block in flash; if that storage is at the start of an erase block, that block is erased first.</li>
</ul>
<p>By this process, there is always a valid parameter block in flash. If power is lost while writing a new parameter block, the checksum will not match and the partially written parameter block will be ignored. This is what makes this fault-tolerant.</p>
<p>Another benefit of this scheme is that it provides wear leveling on the flash. Since multiple parameter blocks fit into each erase block of flash, and multiple erase blocks are used for parameter block storage, it takes quite a few parameter block saves before flash is re-written.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f202e339edf1758a8b484afa19fb074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FlashPBSave </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pui8Buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a new parameter block to flash.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pui8Buffer</td><td>is the address of the parameter block to be written to flash.</td></tr>
  </table>
  </dd>
</dl>
<p>This function will write a parameter block to flash. Saving the new parameter blocks involves three steps:</p>
<ul>
<li>Setting the sequence number such that it is one greater than the sequence number of the latest parameter block in flash.</li>
<li>Computing the checksum of the parameter block.</li>
<li>Writing the parameter block into the storage immediately following the latest parameter block in flash; if that storage is at the start of an erase block, that block is erased first.</li>
</ul>
<p>By this process, there is always a valid parameter block in flash. If power is lost while writing a new parameter block, the checksum will not match and the partially written parameter block will be ignored. This is what makes this fault-tolerant.</p>
<p>Another benefit of this scheme is that it provides wear leveling on the flash. Since multiple parameter blocks fit into each erase block of flash, and multiple erase blocks are used for parameter block storage, it takes quite a few parameter block saves before flash is re-written.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 22 2014 11:10:35 for Zigbee Module Examples by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
