<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Zigbee Module Examples: Ethernet_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Module Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ethernet_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga69a0b07b00606cde6460a005a465e4f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga69a0b07b00606cde6460a005a465e4f9">EthernetInitExpClk</a> (unsigned long ulBase, unsigned long ulEthClk)</td></tr>
<tr class="memitem:ga4fff12e564a12940c8241fa82d4c2f3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga4fff12e564a12940c8241fa82d4c2f3b">EthernetConfigSet</a> (unsigned long ulBase, unsigned long ulConfig)</td></tr>
<tr class="memitem:ga167d5b1f42772ba193b38a5a24992d72"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga167d5b1f42772ba193b38a5a24992d72">EthernetConfigGet</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:ga8b99a7111e5f841039d99011d0d3b31a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga8b99a7111e5f841039d99011d0d3b31a">EthernetMACAddrSet</a> (unsigned long ulBase, unsigned char *pucMACAddr)</td></tr>
<tr class="memitem:gafdbc7b014f1415ccadb5fdc5b621df84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gafdbc7b014f1415ccadb5fdc5b621df84">EthernetMACAddrGet</a> (unsigned long ulBase, unsigned char *pucMACAddr)</td></tr>
<tr class="memitem:ga8acd35f723f93cbe8a2c8dae755a6d55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga8acd35f723f93cbe8a2c8dae755a6d55">EthernetEnable</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:gaff9c56ef8e8550495838a480080e3795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gaff9c56ef8e8550495838a480080e3795">EthernetDisable</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:gacb3100844829f61122fac46772892f8f"><td class="memItemLeft" align="right" valign="top">tBoolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gacb3100844829f61122fac46772892f8f">EthernetPacketAvail</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:ga48b7a86260108f39c0d2098663947b2b"><td class="memItemLeft" align="right" valign="top">tBoolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga48b7a86260108f39c0d2098663947b2b">EthernetSpaceAvail</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:gab36e318fdee23217b21d32845882ec2c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gab36e318fdee23217b21d32845882ec2c">EthernetPacketGetNonBlocking</a> (unsigned long ulBase, unsigned char *pucBuf, long lBufLen)</td></tr>
<tr class="memitem:gad072f06ac1a3e6e73035da175b7735a2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gad072f06ac1a3e6e73035da175b7735a2">EthernetPacketGet</a> (unsigned long ulBase, unsigned char *pucBuf, long lBufLen)</td></tr>
<tr class="memitem:gad9e08fadba00f7112a0c3f8c4f048c1b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gad9e08fadba00f7112a0c3f8c4f048c1b">EthernetPacketPutNonBlocking</a> (unsigned long ulBase, unsigned char *pucBuf, long lBufLen)</td></tr>
<tr class="memitem:ga6edec2ea9fe3b985ab0cdcd7f0c9907a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga6edec2ea9fe3b985ab0cdcd7f0c9907a">EthernetPacketPut</a> (unsigned long ulBase, unsigned char *pucBuf, long lBufLen)</td></tr>
<tr class="memitem:ga41fc8d47036f8d2bdb16284e2192826f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga41fc8d47036f8d2bdb16284e2192826f">EthernetIntRegister</a> (unsigned long ulBase, void(*pfnHandler)(void))</td></tr>
<tr class="memitem:ga1d10f308e1809059d66d8c162b4dcf48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga1d10f308e1809059d66d8c162b4dcf48">EthernetIntUnregister</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:ga46c0fb26c855d23011be05c164aae9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga46c0fb26c855d23011be05c164aae9d6">EthernetIntEnable</a> (unsigned long ulBase, unsigned long ulIntFlags)</td></tr>
<tr class="memitem:ga88c4148bbdee1bd47dc86af402058aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga88c4148bbdee1bd47dc86af402058aa3">EthernetIntDisable</a> (unsigned long ulBase, unsigned long ulIntFlags)</td></tr>
<tr class="memitem:ga0b55e174a9d501dcae056df8cb100992"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga0b55e174a9d501dcae056df8cb100992">EthernetIntStatus</a> (unsigned long ulBase, tBoolean bMasked)</td></tr>
<tr class="memitem:gaf29328bc223f631206a68f5981267474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gaf29328bc223f631206a68f5981267474">EthernetIntClear</a> (unsigned long ulBase, unsigned long ulIntFlags)</td></tr>
<tr class="memitem:ga1733d656b06bb65989749f7d3bf59563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga1733d656b06bb65989749f7d3bf59563">EthernetPHYAddrSet</a> (unsigned long ulBase, unsigned char ucAddr)</td></tr>
<tr class="memitem:gadcdfd3c0502e1a2de455c8645c3e924c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gadcdfd3c0502e1a2de455c8645c3e924c">EthernetPHYWrite</a> (unsigned long ulBase, unsigned char ucRegAddr, unsigned long ulData)</td></tr>
<tr class="memitem:ga48ccedbad61363cce6b634686c659c52"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga48ccedbad61363cce6b634686c659c52">EthernetPHYRead</a> (unsigned long ulBase, unsigned char ucRegAddr)</td></tr>
<tr class="memitem:ga37c3489c5e75c8f176d74f691899136a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#ga37c3489c5e75c8f176d74f691899136a">EthernetPHYPowerOff</a> (unsigned long ulBase)</td></tr>
<tr class="memitem:gae58f8c72de5e81962e478c1534045f05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ethernet__api.html#gae58f8c72de5e81962e478c1534045f05">EthernetPHYPowerOn</a> (unsigned long ulBase)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga167d5b1f42772ba193b38a5a24992d72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long EthernetConfigGet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current configuration of the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function queries the control registers of the Ethernet controller and returns a bit-mapped configuration value.</p>
<dl class="section see"><dt>See also:</dt><dd>The description of the <a class="el" href="group__ethernet__api.html#ga4fff12e564a12940c8241fa82d4c2f3b">EthernetConfigSet()</a> function provides detailed information for the bit-mapped configuration values that are returned.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns the bit-mapped Ethernet controller configuration value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fff12e564a12940c8241fa82d4c2f3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetConfigSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the configuration of the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ulConfig</td><td>is the configuration for the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>After the <a class="el" href="group__ethernet__api.html#ga69a0b07b00606cde6460a005a465e4f9">EthernetInitExpClk()</a> function has been called, this API function can be used to configure the various features of the Ethernet controller.</p>
<p>The Ethernet controller provides three control registers that are used to configure the controller's operation. The transmit control register provides settings to enable full-duplex operation, to auto-generate the frame check sequence, and to pad the transmit packets to the minimum length as required by the IEEE standard. The receive control register provides settings to enable reception of packets with bad frame check sequence values and to enable multi-cast or promiscuous modes. The timestamp control register provides settings that enable support logic in the controller that allow the use of the General Purpose Timer 3 to capture timestamps for the transmitted and received packets. Note that not all devices support this functionality; see the data sheet to determine if this feature is supported.</p>
<p>The <em>ulConfig</em> parameter is the logical OR of the following values:</p>
<ul>
<li><b>ETH_CFG_TS_TSEN</b> - Enable TX and RX interrupt status as CCP timer inputs</li>
<li><b>ETH_CFG_RX_BADCRCDIS</b> - Disable reception of packets with a bad CRC</li>
<li><b>ETH_CFG_RX_PRMSEN</b> - Enable promiscuous mode reception (all packets)</li>
<li><b>ETH_CFG_RX_AMULEN</b> - Enable reception of multicast packets</li>
<li><b>ETH_CFG_TX_DPLXEN</b> - Enable full duplex transmit mode</li>
<li><b>ETH_CFG_TX_CRCEN</b> - Enable transmit with auto CRC generation</li>
<li><b>ETH_CFG_TX_PADEN</b> - Enable padding of transmit data to minimum size</li>
</ul>
<p>These bit-mapped values are programmed into the transmit, receive, and/or timestamp control register.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff9c56ef8e8550495838a480080e3795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>When terminating operations on the Ethernet interface, this function should be called. This function disables the transmitter and receiver, and clears out the receive FIFO.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8acd35f723f93cbe8a2c8dae755a6d55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the Ethernet controller for normal operation.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>Once the Ethernet controller has been configured using the <a class="el" href="group__ethernet__api.html#ga4fff12e564a12940c8241fa82d4c2f3b">EthernetConfigSet()</a> function and the MAC address has been programmed using the <a class="el" href="group__ethernet__api.html#ga8b99a7111e5f841039d99011d0d3b31a">EthernetMACAddrSet()</a> function, this API function can be called to enable the controller for normal operation.</p>
<p>This function enables the controller's transmitter and receiver, and resets the receive FIFO.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga69a0b07b00606cde6460a005a465e4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetInitExpClk </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulEthClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the Ethernet controller for operation.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ulEthClk</td><td>is the rate of the clock supplied to the Ethernet module.</td></tr>
  </table>
  </dd>
</dl>
<p>This function prepares the Ethernet controller for first-time use in a given hardware/software configuration. This function should be called before any other Ethernet API functions are called.</p>
<p>The peripheral clock is the same as the processor clock. This value is returned by <a class="el" href="group__sysctl__api.html#ga7fd64f17ef7b589c51d72df5837f13eb">SysCtlClockGet()</a>, or it can be explicitly hard-coded if it is constant and known (to save the code/execution overhead of a call to <a class="el" href="group__sysctl__api.html#ga7fd64f17ef7b589c51d72df5837f13eb">SysCtlClockGet()</a>).</p>
<p>This function replaces the original EthernetInit() API and performs the same actions. A macro is provided in <code>ethernet.h</code> to map the original API to this API.</p>
<dl class="section note"><dt>Note:</dt><dd>If the device configuration is changed (for example, the system clock is reprogrammed to a different speed), then the Ethernet controller must be disabled by calling the <a class="el" href="group__ethernet__api.html#gaff9c56ef8e8550495838a480080e3795">EthernetDisable()</a> function and the controller must be reinitialized by calling the <a class="el" href="group__ethernet__api.html#ga69a0b07b00606cde6460a005a465e4f9">EthernetInitExpClk()</a> function again. After the controller has been reinitialized, the controller should be reconfigured using the appropriate Ethernet API calls.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf29328bc223f631206a68f5981267474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetIntClear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears Ethernet interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ulIntFlags</td><td>is a bit mask of the interrupt sources to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified Ethernet interrupt sources are cleared so that they no longer assert. This function must be called in the interrupt handler to keep the interrupt from being triggered again immediately upon exit.</p>
<p>The <em>ulIntFlags</em> parameter has the same definition as the <em>ulIntFlags</em> parameter to <a class="el" href="group__ethernet__api.html#ga46c0fb26c855d23011be05c164aae9d6">EthernetIntEnable()</a>.</p>
<dl class="section note"><dt>Note:</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88c4148bbdee1bd47dc86af402058aa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetIntDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual Ethernet interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ulIntFlags</td><td>is the bit mask of the interrupt sources to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Disables the indicated Ethernet interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ulIntFlags</em> parameter has the same definition as the <em>ulIntFlags</em> parameter to <a class="el" href="group__ethernet__api.html#ga46c0fb26c855d23011be05c164aae9d6">EthernetIntEnable()</a>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga46c0fb26c855d23011be05c164aae9d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetIntEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIntFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual Ethernet interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ulIntFlags</td><td>is the bit mask of the interrupt sources to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated Ethernet interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<p>The <em>ulIntFlags</em> parameter is the logical OR of any of the following:</p>
<ul>
<li><b>ETH_INT_PHY</b> - An interrupt from the PHY has occurred. The integrated PHY supports a number of interrupt conditions. The appropriate PHY register, PHY_MR17 or PHY_MR29 depending on the device class, must be read to determine which PHY interrupt has occurred. This register can be read using the <a class="el" href="group__ethernet__api.html#ga48ccedbad61363cce6b634686c659c52">EthernetPHYRead()</a> API function.</li>
<li><b>ETH_INT_MDIO</b> - This interrupt indicates that a transaction on the management interface has completed successfully.</li>
<li><b>ETH_INT_RXER</b> - This interrupt indicates that an error has occurred during reception of a frame. This error can indicate a length mismatch, a CRC failure, or an error indication from the PHY.</li>
<li><b>ETH_INT_RXOF</b> - This interrupt indicates that a frame has been received that exceeds the available space in the RX FIFO.</li>
<li><b>ETH_INT_TX</b> - This interrupt indicates that the packet stored in the TX FIFO has been successfully transmitted.</li>
<li><b>ETH_INT_TXER</b> - This interrupt indicates that an error has occurred during the transmission of a packet. This error can be either a retry failure during the back-off process, or an invalid length stored in the TX FIFO.</li>
<li><b>ETH_INT_RX</b> - This interrupt indicates that one (or more) packets are available in the RX FIFO for processing.</li>
</ul>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41fc8d47036f8d2bdb16284e2192826f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetIntRegister </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for an Ethernet interrupt.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the enabled Ethernet interrupts occur.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the handler to be called when the Ethernet interrupt occurs. This function enables the global interrupt in the interrupt controller; specific Ethernet interrupts must be enabled via <a class="el" href="group__ethernet__api.html#ga46c0fb26c855d23011be05c164aae9d6">EthernetIntEnable()</a>. It is the interrupt handler's responsibility to clear the interrupt source.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b55e174a9d501dcae056df8cb100992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long EthernetIntStatus </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bMasked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current Ethernet interrupt status.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is required and true if the masked interrupt status is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the Ethernet controller. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the current interrupt status, enumerated as a bit field of values described in <a class="el" href="group__ethernet__api.html#ga46c0fb26c855d23011be05c164aae9d6">EthernetIntEnable()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d10f308e1809059d66d8c162b4dcf48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetIntUnregister </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters an interrupt handler for an Ethernet interrupt.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function unregisters the interrupt handler. This function disables the global interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gafdbc7b014f1415ccadb5fdc5b621df84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetMACAddrGet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucMACAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the MAC address of the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucMACAddr</td><td>is the pointer to the location in which to store the array of MAC-48 address octets.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the currently programmed MAC address into the <em>pucMACAddr</em> buffer.</p>
<dl class="section see"><dt>See also:</dt><dd>Refer to <a class="el" href="group__ethernet__api.html#ga8b99a7111e5f841039d99011d0d3b31a">EthernetMACAddrSet()</a> API description for more details about the MAC <a class="el" href="hal__bit__bang__i2c_8c.html#af3f726014b044194def151079f1f2d89">address</a> format.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b99a7111e5f841039d99011d0d3b31a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetMACAddrSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucMACAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the MAC address of the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucMACAddr</td><td>is the pointer to the array of MAC-48 address octets.</td></tr>
  </table>
  </dd>
</dl>
<p>This function programs the IEEE-defined MAC-48 address specified in <em>pucMACAddr</em> into the Ethernet controller. This address is used by the Ethernet controller for hardware-level filtering of incoming Ethernet packets (when promiscuous mode is not enabled).</p>
<p>The MAC-48 address is defined as 6 octets, illustrated by the following example address. The numbers are shown in hexadecimal format. </p>
<pre class="fragment">    AC-DE-48-00-00-80
</pre><p>In this representation, the first three octets (AC-DE-48) are the Organizationally Unique Identifier (OUI). This is a number assigned by the IEEE to an organization that requests a block of MAC addresses. The last three octets (00-00-80) are a 24-bit number managed by the OUI owner to uniquely identify a piece of hardware within that organization that is to be connected to the Ethernet.</p>
<p>In this representation, the octets are transmitted from left to right, with the <code>AC'' octet being transmitted first and the</code>80'' octet being transmitted last. Within an octet, the bits are transmitted LSB to MSB. For this address, the first bit to be transmitted would be <code>0'', the LSB of</code>AC'', and the last bit to be transmitted would be <code>1'', the MSB of </code>80''.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb3100844829f61122fac46772892f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBoolean EthernetPacketAvail </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for packet available from the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>The Ethernet controller provides a register that contains the number of packets available in the receive FIFO. When the last bytes of a packet are successfully received (that is, the frame check sequence bytes), the packet count is incremented. Once the packet has been fully read (including the frame check sequence bytes) from the FIFO, the packet count is decremented.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if there are one or more packets available in the receive FIFO, including the current packet being read, and <b>false</b> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gad072f06ac1a3e6e73035da175b7735a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long EthernetPacketGet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits for a packet from the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucBuf</td><td>is the pointer to the packet buffer. </td></tr>
    <tr><td class="paramname">lBufLen</td><td>is the maximum number of bytes to be read into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a packet from the receive FIFO of the controller and places it into <em>pucBuf</em>. The function waits until a packet is available in the FIFO. Then the function reads the entire packet from the receive FIFO. If there are more bytes in the packet than can fit into <em>pucBuf</em> (as specified by <em>lBufLen</em>), the function returns the negated length of the packet and the buffer contains <em>lBufLen</em> bytes of the packet. Otherwise, the function returns the length of the packet that was read and <em>pucBuf</em> contains the entire packet (excluding the frame check sequence bytes).</p>
<dl class="section note"><dt>Note:</dt><dd>This function is blocking and does not return until a packet arrives.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns the negated packet length <b>-n</b> if the packet is too large for <em>pucBuf</em>, and returns the packet length <b>n</b> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gab36e318fdee23217b21d32845882ec2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long EthernetPacketGetNonBlocking </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a packet from the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucBuf</td><td>is the pointer to the packet buffer. </td></tr>
    <tr><td class="paramname">lBufLen</td><td>is the maximum number of bytes to be read into the buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads a packet from the receive FIFO of the controller and places it into <em>pucBuf</em>. If no packet is available the function returns immediately. Otherwise, the function reads the entire packet from the receive FIFO. If there are more bytes in the packet than can fit into <em>pucBuf</em> (as specified by <em>lBufLen</em>), the function returns the negated length of the packet and the buffer contains <em>lBufLen</em> bytes of the packet. Otherwise, the function returns the length of the packet that was read and <em>pucBuf</em> contains the entire packet (excluding the frame check sequence bytes).</p>
<p>This function replaces the original EthernetPacketNonBlockingGet() API and performs the same actions. A macro is provided in <code>ethernet.h</code> to map the original API to this API.</p>
<dl class="section note"><dt>Note:</dt><dd>This function returns immediately if no packet is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>0</b> if no packet is available, the negated packet length <b>-n</b> if the packet is too large for <em>pucBuf</em>, and the packet length <b>n</b> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6edec2ea9fe3b985ab0cdcd7f0c9907a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long EthernetPacketPut </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits to send a packet from the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucBuf</td><td>is the pointer to the packet buffer. </td></tr>
    <tr><td class="paramname">lBufLen</td><td>is number of bytes in the packet to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes <em>lBufLen</em> bytes of the packet contained in <em>pucBuf</em> into the transmit FIFO of the controller and then activates the transmitter for this packet. This function waits until the transmit FIFO is empty. Once space is available, the function returns once <em>lBufLen</em> bytes of the packet have been placed into the FIFO and the transmitter has been started. The function does not wait for the transmission to complete. The function returns the negated <em>lBufLen</em> if the length is larger than the space available in the transmit FIFO.</p>
<dl class="section note"><dt>Note:</dt><dd>This function blocks and waits until space is available for the transmit packet before returning.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns the negated packet length <b>-lBufLen</b> if the packet is too large for FIFO, and the packet length <b>lBufLen</b> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9e08fadba00f7112a0c3f8c4f048c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long EthernetPacketPutNonBlocking </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>pucBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>lBufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a packet to the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">pucBuf</td><td>is the pointer to the packet buffer. </td></tr>
    <tr><td class="paramname">lBufLen</td><td>is number of bytes in the packet to be transmitted.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes <em>lBufLen</em> bytes of the packet contained in <em>pucBuf</em> into the transmit FIFO of the controller and then activates the transmitter for this packet. If no space is available in the FIFO, the function returns immediately. If space is available, the function returns once <em>lBufLen</em> bytes of the packet have been placed into the FIFO and the transmitter has been started. The function does not wait for the transmission to complete. The function returns the negated <em>lBufLen</em> if the length is larger than the space available in the transmit FIFO.</p>
<p>This function replaces the original EthernetPacketNonBlockingPut() API and performs the same actions. A macro is provided in <code>ethernet.h</code> to map the original API to this API.</p>
<dl class="section note"><dt>Note:</dt><dd>This function does not block and returns immediately if no space is available for the transmit packet.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>0</b> if no space is available in the transmit FIFO, the negated packet length <b>-lBufLen</b> if the packet is too large for FIFO, and the packet length <b>lBufLen</b> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1733d656b06bb65989749f7d3bf59563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetPHYAddrSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PHY address.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ucAddr</td><td>is the address of the PHY.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the address of the PHY that is accessed via <a class="el" href="group__ethernet__api.html#ga48ccedbad61363cce6b634686c659c52">EthernetPHYRead()</a> and EthernePHYWrite(). This configuration is only needed when connecting to an external PHY via MII, and should not be used on devices that have integrated PHYs.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga37c3489c5e75c8f176d74f691899136a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetPHYPowerOff </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers off the Ethernet PHY.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function powers off the Ethernet PHY, reducing the current consumption of the device. While in the powered off state, the Ethernet controller is unable to connect to the Ethernet.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae58f8c72de5e81962e478c1534045f05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetPHYPowerOn </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers on the Ethernet PHY.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>This function powers on the Ethernet PHY, enabling it return to normal operation. By default, the PHY is powered on, so this function is only called if <a class="el" href="group__ethernet__api.html#ga37c3489c5e75c8f176d74f691899136a">EthernetPHYPowerOff()</a> has previously been called.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48ccedbad61363cce6b634686c659c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long EthernetPHYRead </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucRegAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads from a PHY register.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ucRegAddr</td><td>is the address of the PHY register to be accessed.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the contents of the PHY register specified by <em>ucRegAddr</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the 16-bit value read from the PHY. </dd></dl>

</div>
</div>
<a class="anchor" id="gadcdfd3c0502e1a2de455c8645c3e924c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EthernetPHYWrite </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ucRegAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the PHY register.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller. </td></tr>
    <tr><td class="paramname">ucRegAddr</td><td>is the address of the PHY register to be accessed. </td></tr>
    <tr><td class="paramname">ulData</td><td>is the data to be written to the PHY register.</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the <em>ulData</em> to the PHY register specified by <em>ucRegAddr</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga48b7a86260108f39c0d2098663947b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBoolean EthernetSpaceAvail </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulBase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for packet space available in the Ethernet controller.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulBase</td><td>is the base address of the controller.</td></tr>
  </table>
  </dd>
</dl>
<p>The Ethernet controller's transmit FIFO is designed to support a single packet at a time. After the packet has been written into the FIFO, the transmit request bit must be set to enable the transmission of the packet. Only after the packet has been transmitted can a new packet be written into the FIFO. This function simply checks to see if a packet is in progress. If so, there is no space available in the transmit FIFO.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if a space is available in the transmit FIFO, and <b>false</b> otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 22 2014 11:10:35 for Zigbee Module Examples by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
