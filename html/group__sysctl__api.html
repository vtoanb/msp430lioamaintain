<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Zigbee Module Examples: Sysctl_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Module Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sysctl_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga964a824e22039a7b4191aac3a785c26d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga964a824e22039a7b4191aac3a785c26d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PPBASE</b>&#160;&#160;&#160;0x400fe300</td></tr>
<tr class="memitem:ga728149fdb5d71e5ad29f79fa143beeaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga728149fdb5d71e5ad29f79fa143beeaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_SRBASE</b>&#160;&#160;&#160;0x400fe500</td></tr>
<tr class="memitem:ga06ebceaf21699c2734ece677f50757bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06ebceaf21699c2734ece677f50757bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_RCGCBASE</b>&#160;&#160;&#160;0x400fe600</td></tr>
<tr class="memitem:gaa1107dc41d3c5c0ab71df0a55ebbcb3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1107dc41d3c5c0ab71df0a55ebbcb3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_SCGCBASE</b>&#160;&#160;&#160;0x400fe700</td></tr>
<tr class="memitem:ga66fef5e82d99e1417797cf570cc8574f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66fef5e82d99e1417797cf570cc8574f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_DCGCBASE</b>&#160;&#160;&#160;0x400fe800</td></tr>
<tr class="memitem:ga82a193fd8d66ec461b8a67e0604d99f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82a193fd8d66ec461b8a67e0604d99f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PCBASE</b>&#160;&#160;&#160;0x400fe900</td></tr>
<tr class="memitem:gab339add73c43f8b19bfa850e0fc999ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab339add73c43f8b19bfa850e0fc999ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PRBASE</b>&#160;&#160;&#160;0x400fea00</td></tr>
<tr class="memitem:ga3858112ac2b49922658c485a0bab3087"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3858112ac2b49922658c485a0bab3087"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PERIPH_INDEX</b>(a)&#160;&#160;&#160;(((a) &gt;&gt; 28) &amp; 0xf)</td></tr>
<tr class="memitem:gae5675ec89e14eded93d5723488ad5f7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5675ec89e14eded93d5723488ad5f7b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PERIPH_MASK</b>(a)&#160;&#160;&#160;(((a) &amp; 0xffff) &lt;&lt; (((a) &amp; 0x001f0000) &gt;&gt; 16))</td></tr>
<tr class="memitem:ga964a824e22039a7b4191aac3a785c26d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga964a824e22039a7b4191aac3a785c26d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PPBASE</b>&#160;&#160;&#160;0x400fe300</td></tr>
<tr class="memitem:ga728149fdb5d71e5ad29f79fa143beeaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga728149fdb5d71e5ad29f79fa143beeaa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_SRBASE</b>&#160;&#160;&#160;0x400fe500</td></tr>
<tr class="memitem:ga06ebceaf21699c2734ece677f50757bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06ebceaf21699c2734ece677f50757bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_RCGCBASE</b>&#160;&#160;&#160;0x400fe600</td></tr>
<tr class="memitem:gaa1107dc41d3c5c0ab71df0a55ebbcb3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1107dc41d3c5c0ab71df0a55ebbcb3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_SCGCBASE</b>&#160;&#160;&#160;0x400fe700</td></tr>
<tr class="memitem:ga66fef5e82d99e1417797cf570cc8574f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66fef5e82d99e1417797cf570cc8574f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_DCGCBASE</b>&#160;&#160;&#160;0x400fe800</td></tr>
<tr class="memitem:ga82a193fd8d66ec461b8a67e0604d99f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga82a193fd8d66ec461b8a67e0604d99f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PCBASE</b>&#160;&#160;&#160;0x400fe900</td></tr>
<tr class="memitem:gab339add73c43f8b19bfa850e0fc999ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab339add73c43f8b19bfa850e0fc999ec"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SYSCTL_PRBASE</b>&#160;&#160;&#160;0x400fea00</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga885c5d8317952b063d39c8291981e499"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga885c5d8317952b063d39c8291981e499">SysCtlSRAMSizeGet</a> (void)</td></tr>
<tr class="memitem:ga8e91559f5cd697cd17c467ea1003c2d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga8e91559f5cd697cd17c467ea1003c2d9">SysCtlFlashSizeGet</a> (void)</td></tr>
<tr class="memitem:ga8b1d6a1177370abf4bdda1bdf49236c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga8b1d6a1177370abf4bdda1bdf49236c6">SysCtlPeripheralPresent</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga7ddf1f06376894c31e5596f562c299ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7ddf1f06376894c31e5596f562c299ac">SysCtlPeripheralReady</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga0cf69aace5f096e92b7908fbe5e7fdc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga0cf69aace5f096e92b7908fbe5e7fdc5">SysCtlPeripheralPowerOn</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga18c4cbb616f0b37b806914543e2a09b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga18c4cbb616f0b37b806914543e2a09b4">SysCtlPeripheralPowerOff</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:gab8c537abe40caacd5dfa7ffdedefb6b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab8c537abe40caacd5dfa7ffdedefb6b9">SysCtlPeripheralReset</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga2fbae61db465e1d861a62785d28e3ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga41000fce023961157e6031ac94ff1f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga41000fce023961157e6031ac94ff1f3a">SysCtlPeripheralDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga88db79b809decde9d228ee2c3e58a727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:gaa1131a3d12965af7cdaa02f0649dc237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:gad412f63e83618b3085f324778b1fd606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga8f46fff4f83f6e6771b9839fe58d209a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable</a> (uint32_t ui32Peripheral)</td></tr>
<tr class="memitem:ga0ad7b6dcec84339f2bbb8663551cc7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating</a> (bool bEnable)</td></tr>
<tr class="memitem:gaad3caf3c0e7eddea266b7dc2fcb121c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaad3caf3c0e7eddea266b7dc2fcb121c4">SysCtlIntRegister</a> (void(*pfnHandler)(void))</td></tr>
<tr class="memitem:ga96fa0579c653617672244b6a280d9897"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga96fa0579c653617672244b6a280d9897">SysCtlIntUnregister</a> (void)</td></tr>
<tr class="memitem:ga4d75a6ab7e4a0d8fb88d7ef9359b2adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable</a> (uint32_t ui32Ints)</td></tr>
<tr class="memitem:gaae3131c668931a976c6005d17135693b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaae3131c668931a976c6005d17135693b">SysCtlIntDisable</a> (uint32_t ui32Ints)</td></tr>
<tr class="memitem:gad6c94773880c951cdfe70b387626d081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear</a> (uint32_t ui32Ints)</td></tr>
<tr class="memitem:gab10bfca29c2ba2a5ad80f8c57192ef7d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab10bfca29c2ba2a5ad80f8c57192ef7d">SysCtlIntStatus</a> (bool bMasked)</td></tr>
<tr class="memitem:ga7e7eaf3273efa935f7bedfd3760d11b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7e7eaf3273efa935f7bedfd3760d11b8">SysCtlReset</a> (void)</td></tr>
<tr class="memitem:ga90efcbaddc41095b9567cae626aaeb2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga90efcbaddc41095b9567cae626aaeb2c">SysCtlSleep</a> (void)</td></tr>
<tr class="memitem:gac54fcca75df0066bd2b2ecdf92c0eda2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac54fcca75df0066bd2b2ecdf92c0eda2">SysCtlDeepSleep</a> (void)</td></tr>
<tr class="memitem:ga7db50d4000d8905c341d79bd75fcc9bb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7db50d4000d8905c341d79bd75fcc9bb">SysCtlResetCauseGet</a> (void)</td></tr>
<tr class="memitem:gab9735274e5c9468bb55ecde9ca07bfb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab9735274e5c9468bb55ecde9ca07bfb1">SysCtlResetCauseClear</a> (uint32_t ui32Causes)</td></tr>
<tr class="memitem:gaa5ea49a00d023774f052fc53a2ccb953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa5ea49a00d023774f052fc53a2ccb953">SysCtlMOSCConfigSet</a> (uint32_t ui32Config)</td></tr>
<tr class="memitem:gaf5bd79f60945f405c34c89005b0eb50d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf5bd79f60945f405c34c89005b0eb50d">SysCtlPIOSCCalibrate</a> (uint32_t ui32Type)</td></tr>
<tr class="memitem:gab9c9f4e4588e1e9c5b42e3c3b109e5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gab9c9f4e4588e1e9c5b42e3c3b109e5c1">SysCtlClockSet</a> (uint32_t ui32Config)</td></tr>
<tr class="memitem:ga7fd64f17ef7b589c51d72df5837f13eb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7fd64f17ef7b589c51d72df5837f13eb">SysCtlClockGet</a> (void)</td></tr>
<tr class="memitem:ga744cd0f180b45ce693702fd074acb1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga744cd0f180b45ce693702fd074acb1db">SysCtlDeepSleepClockSet</a> (uint32_t ui32Config)</td></tr>
<tr class="memitem:ga444e7a242f14e945fcc7a909d13d2d3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga444e7a242f14e945fcc7a909d13d2d3c">SysCtlPWMClockSet</a> (uint32_t ui32Config)</td></tr>
<tr class="memitem:ga2cad830172c4c26ebe550bec5cc63250"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2cad830172c4c26ebe550bec5cc63250">SysCtlPWMClockGet</a> (void)</td></tr>
<tr class="memitem:gae710b89722000d24eb23ff2f6d6554dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gae710b89722000d24eb23ff2f6d6554dc">SysCtlADCSpeedSet</a> (uint32_t ui32Speed)</td></tr>
<tr class="memitem:ga9d1998582e9e61e2b7a97d9d2baf6361"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga9d1998582e9e61e2b7a97d9d2baf6361">SysCtlADCSpeedGet</a> (void)</td></tr>
<tr class="memitem:gadf2447348f48b339b8e7a73ed5e80afd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gadf2447348f48b339b8e7a73ed5e80afd">SysCtlGPIOAHBEnable</a> (uint32_t ui32GPIOPeripheral)</td></tr>
<tr class="memitem:ga319195ed040b6d8ddaee3ca5ea562606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga319195ed040b6d8ddaee3ca5ea562606">SysCtlGPIOAHBDisable</a> (uint32_t ui32GPIOPeripheral)</td></tr>
<tr class="memitem:ga9af839cfa9e1635c3d437b7f466c0e03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga9af839cfa9e1635c3d437b7f466c0e03">SysCtlUSBPLLEnable</a> (void)</td></tr>
<tr class="memitem:ga980dda99cd999c319351c2c24992d9a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga980dda99cd999c319351c2c24992d9a6">SysCtlUSBPLLDisable</a> (void)</td></tr>
<tr class="memitem:gac2880e79802ff713958523e026a9e045"><td class="memItemLeft" align="right" valign="top">tBoolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gac2880e79802ff713958523e026a9e045">SysCtlPinPresent</a> (unsigned long ulPin)</td></tr>
<tr class="memitem:ga563015090350777d6781e622d6f41b16"><td class="memItemLeft" align="right" valign="top">tBoolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga563015090350777d6781e622d6f41b16">SysCtlPeripheralPresent</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:gad09146a19c9e7a73768e68c363cf1ead"><td class="memItemLeft" align="right" valign="top">tBoolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad09146a19c9e7a73768e68c363cf1ead">SysCtlPeripheralReady</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:gaea8b8285a15845064a909e77f30a0c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaea8b8285a15845064a909e77f30a0c72">SysCtlPeripheralPowerOn</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga2a74275e3ee4077a4ff11ce8d8363de6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2a74275e3ee4077a4ff11ce8d8363de6">SysCtlPeripheralPowerOff</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga9d110072f28bc077c022ae393026e198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga9d110072f28bc077c022ae393026e198">SysCtlPeripheralReset</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:gabe04fe3c0a202f2b2c12945523a8003b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gabe04fe3c0a202f2b2c12945523a8003b">SysCtlPeripheralEnable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga2c6ae288a5a775030ec42032f98b5ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2c6ae288a5a775030ec42032f98b5ac1">SysCtlPeripheralDisable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga2284e21081949f00e226c6a54bc32ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga2284e21081949f00e226c6a54bc32ac9">SysCtlPeripheralSleepEnable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga6fa1e488302b32666771970252e82964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga6fa1e488302b32666771970252e82964">SysCtlPeripheralSleepDisable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga01e3073f0a62b957ace580b48bbb225f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga01e3073f0a62b957ace580b48bbb225f">SysCtlPeripheralDeepSleepEnable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:gacb5e6b7ec4ef56efce1a2f878c1057fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gacb5e6b7ec4ef56efce1a2f878c1057fe">SysCtlPeripheralDeepSleepDisable</a> (unsigned long ulPeripheral)</td></tr>
<tr class="memitem:ga9d308b9f15c38733fb3b3b702b821324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga9d308b9f15c38733fb3b3b702b821324">SysCtlPeripheralClockGating</a> (tBoolean bEnable)</td></tr>
<tr class="memitem:gad0f4f34f6717ae0c41934937d602a53d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad0f4f34f6717ae0c41934937d602a53d">SysCtlIntEnable</a> (unsigned long ulInts)</td></tr>
<tr class="memitem:ga7f60dde986750017796830ca7339ceef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga7f60dde986750017796830ca7339ceef">SysCtlIntDisable</a> (unsigned long ulInts)</td></tr>
<tr class="memitem:ga5800d87d0cb3c581a443ba69d4f9ff47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga5800d87d0cb3c581a443ba69d4f9ff47">SysCtlIntClear</a> (unsigned long ulInts)</td></tr>
<tr class="memitem:ga20458dd7afe7fa08e51aea0c3a31526e"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga20458dd7afe7fa08e51aea0c3a31526e">SysCtlIntStatus</a> (tBoolean bMasked)</td></tr>
<tr class="memitem:ga371e823da4cd004df3517874781674e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga371e823da4cd004df3517874781674e5">SysCtlLDOSet</a> (unsigned long ulVoltage)</td></tr>
<tr class="memitem:gaf2ff010082d26add6df27b893714e019"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf2ff010082d26add6df27b893714e019">SysCtlLDOGet</a> (void)</td></tr>
<tr class="memitem:gadee84f864ab925d0408c35fd9ecc1f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gadee84f864ab925d0408c35fd9ecc1f03">SysCtlLDOConfigSet</a> (unsigned long ulConfig)</td></tr>
<tr class="memitem:gad4acd3ca031af59e42f84fbbd704aa6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gad4acd3ca031af59e42f84fbbd704aa6d">SysCtlResetCauseClear</a> (unsigned long ulCauses)</td></tr>
<tr class="memitem:gaf35221b72f503addace9b4785e262b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaf35221b72f503addace9b4785e262b8c">SysCtlBrownOutConfigSet</a> (unsigned long ulConfig, unsigned long ulDelay)</td></tr>
<tr class="memitem:ga89317ff4273dea216f78ad66bfc9e87a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga89317ff4273dea216f78ad66bfc9e87a">SysCtlMOSCConfigSet</a> (unsigned long ulConfig)</td></tr>
<tr class="memitem:ga061185206da3937dde5c93b03b325579"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga061185206da3937dde5c93b03b325579">SysCtlPIOSCCalibrate</a> (unsigned long ulType)</td></tr>
<tr class="memitem:ga618397c50330f5c9d933dcfab2e79e25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga618397c50330f5c9d933dcfab2e79e25">SysCtlClockSet</a> (unsigned long ulConfig)</td></tr>
<tr class="memitem:ga04b483db497a4cd5d25ef0c34be55b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga04b483db497a4cd5d25ef0c34be55b49">SysCtlDeepSleepClockSet</a> (unsigned long ulConfig)</td></tr>
<tr class="memitem:gacc14db980db9176f65f182e3038d890a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gacc14db980db9176f65f182e3038d890a">SysCtlPWMClockSet</a> (unsigned long ulConfig)</td></tr>
<tr class="memitem:gae48b3909d29c533fcc2a1f06e8c97563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gae48b3909d29c533fcc2a1f06e8c97563">SysCtlADCSpeedSet</a> (unsigned long ulSpeed)</td></tr>
<tr class="memitem:gaba87ddb0c7b406bab3d21976d7870a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaba87ddb0c7b406bab3d21976d7870a47">SysCtlIOSCVerificationSet</a> (tBoolean bEnable)</td></tr>
<tr class="memitem:ga588eb8fcecf50ef0c7a051db102dfcaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga588eb8fcecf50ef0c7a051db102dfcaa">SysCtlMOSCVerificationSet</a> (tBoolean bEnable)</td></tr>
<tr class="memitem:ga596bd847d8e275d44af2998fcaa70f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga596bd847d8e275d44af2998fcaa70f93">SysCtlPLLVerificationSet</a> (tBoolean bEnable)</td></tr>
<tr class="memitem:ga119c34a661c1273949c22f9884b84818"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga119c34a661c1273949c22f9884b84818">SysCtlClkVerificationClear</a> (void)</td></tr>
<tr class="memitem:ga32e193023cb12193646ab25774789bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga32e193023cb12193646ab25774789bde">SysCtlGPIOAHBEnable</a> (unsigned long ulGPIOPeripheral)</td></tr>
<tr class="memitem:ga56d5321a5afcf4fe133143ff07731abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#ga56d5321a5afcf4fe133143ff07731abf">SysCtlGPIOAHBDisable</a> (unsigned long ulGPIOPeripheral)</td></tr>
<tr class="memitem:gaa5bfa1ee7e16f35485e3bc21e7ba6092"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__sysctl__api.html#gaa5bfa1ee7e16f35485e3bc21e7ba6092">SysCtlI2SMClkSet</a> (unsigned long ulInputClock, unsigned long ulMClk)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gae95d31c652049b04cf189d244260abd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae95d31c652049b04cf189d244260abd6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ui32SysDiv</b></td></tr>
<tr class="memitem:ga11cdd77ed4745f57409766ffb0916f89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga11cdd77ed4745f57409766ffb0916f89"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ui32Osc</b></td></tr>
<tr class="memitem:ga70bd034b343dedc4a97f44d1adfefd8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70bd034b343dedc4a97f44d1adfefd8d"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ui32OscSelect</b></td></tr>
<tr class="memitem:gaa1a43e17334740da56c17ac633d0e0c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1a43e17334740da56c17ac633d0e0c2"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>ui32RSClkConfig</b></td></tr>
<tr class="memitem:ga953ef8ab0f9ee121020e0cc843fd02b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga953ef8ab0f9ee121020e0cc843fd02b5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>bNewPLL</b></td></tr>
<tr class="memitem:ga1b2dd5cdfbeab539327721dd254407f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b2dd5cdfbeab539327721dd254407f0"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>ulSysDiv</b></td></tr>
<tr class="memitem:gad0565b5dab59f47875c6b21002a5d016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad0565b5dab59f47875c6b21002a5d016"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>ulOsc</b></td></tr>
<tr class="memitem:gae960a1997df75326bd3a337110b1c35f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae960a1997df75326bd3a337110b1c35f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>ulOscSelect</b></td></tr>
<tr class="memitem:ga81efd74f829c4396662cf85046c7b636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81efd74f829c4396662cf85046c7b636"></a>
tBoolean&#160;</td><td class="memItemRight" valign="bottom"><b>bNewPLL</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga9d1998582e9e61e2b7a97d9d2baf6361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlADCSpeedGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the sample rate of the ADC.</p>
<p>This function gets the current sample rate of the ADC.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the current ADC sample rate; is one of <b>SYSCTL_ADCSPEED_1MSPS</b>, <b>SYSCTL_ADCSPEED_500KSPS</b>, <b>SYSCTL_ADCSPEED_250KSPS</b>, or <b>SYSCTL_ADCSPEED_125KSPS</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae710b89722000d24eb23ff2f6d6554dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlADCSpeedSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample rate of the ADC.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Speed</td><td>is the desired sample rate of the ADC; must be one of <b>SYSCTL_ADCSPEED_1MSPS</b>, <b>SYSCTL_ADCSPEED_500KSPS</b>, <b>SYSCTL_ADCSPEED_250KSPS</b>, or <b>SYSCTL_ADCSPEED_125KSPS</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the rate at which the ADC samples are captured by the ADC block. The sampling speed may be limited by the hardware, so the sample rate may end up being slower than requested. <a class="el" href="group__sysctl__api.html#ga9d1998582e9e61e2b7a97d9d2baf6361">SysCtlADCSpeedGet()</a> returns the actual speed in use.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae48b3909d29c533fcc2a1f06e8c97563"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlADCSpeedSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSpeed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample rate of the ADC.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulSpeed</td><td>is the desired sample rate of the ADC; must be one of <b>SYSCTL_ADCSPEED_1MSPS</b>, <b>SYSCTL_ADCSPEED_500KSPS</b>, <b>SYSCTL_ADCSPEED_250KSPS</b>, or <b>SYSCTL_ADCSPEED_125KSPS</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the rate at which the ADC samples are captured by the ADC block. The sampling speed may be limited by the hardware, so the sample rate may end up being slower than requested. <a class="el" href="group__sysctl__api.html#ga9d1998582e9e61e2b7a97d9d2baf6361">SysCtlADCSpeedGet()</a> returns the actual speed in use.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf35221b72f503addace9b4785e262b8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlBrownOutConfigSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the brown-out control.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the desired configuration of the brown-out control. Must be the logical OR of <b>SYSCTL_BOR_RESET</b> and/or <b>SYSCTL_BOR_RESAMPLE</b>. </td></tr>
    <tr><td class="paramname">ulDelay</td><td>is the number of internal oscillator cycles to wait before resampling an asserted brown-out signal. This value only has meaning when <b>SYSCTL_BOR_RESAMPLE</b> is set and must be less than 8192.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures how the brown-out control operates. It can detect a brown-out by looking at only the brown-out output, or it can wait for it to be active for two consecutive samples separated by a configurable time. When it detects a brown-out condition, it can either reset the device or generate a processor interrupt.</p>
<dl class="section note"><dt>Note:</dt><dd>The availability of the resample feature is only available on Sandstorm-class devices. Please consult the data sheet for the part you are using to determine whether this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga119c34a661c1273949c22f9884b84818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlClkVerificationClear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the clock verification status.</p>
<p>This function clears the status of the clock verification timers, allowing them to assert another failure if detected.</p>
<p>The clock verification timers are only available on Sandstorm-class devices.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fd64f17ef7b589c51d72df5837f13eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlClockGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the processor clock rate.</p>
<p>This function determines the clock rate of the processor clock, which is also the clock rate of the peripheral modules (with the exception of PWM, which has its own clock divider; other peripherals may have different clocking, see the device data sheet for details).</p>
<dl class="section note"><dt>Note:</dt><dd>This cannot return accurate results if <a class="el" href="group__sysctl__api.html#gab9c9f4e4588e1e9c5b42e3c3b109e5c1">SysCtlClockSet()</a> has not been called to configure the clocking of the device, or if the device is directly clocked from a crystal (or a clock source) that is not one of the supported crystal frequencies. In the latter case, this function should be modified to directly return the correct system clock rate.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>The processor clock rate. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9c9f4e4588e1e9c5b42e3c3b109e5c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlClockSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clocking of the device.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required configuration of the device clocking.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the clocking of the device. The input crystal frequency, oscillator to be used, use of the PLL, and the system clock divider are all configured with this function.</p>
<p>The <em>ui32Config</em> parameter is the logical OR of several different values, many of which are grouped into sets where only one can be chosen.</p>
<p>The system clock divider is chosen with one of the following values: <b>SYSCTL_SYSDIV_1</b>, <b>SYSCTL_SYSDIV_2</b>, <b>SYSCTL_SYSDIV_3</b>, ... <b>SYSCTL_SYSDIV_64</b>.</p>
<p>The use of the PLL is chosen with either <b>SYSCTL_USE_PLL</b> or <b>SYSCTL_USE_OSC</b>.</p>
<p>The external crystal frequency is chosen with one of the following values: <b>SYSCTL_XTAL_4MHZ</b>, <b>SYSCTL_XTAL_4_09MHZ</b>, <b>SYSCTL_XTAL_4_91MHZ</b>, <b>SYSCTL_XTAL_5MHZ</b>, <b>SYSCTL_XTAL_5_12MHZ</b>, <b>SYSCTL_XTAL_6MHZ</b>, <b>SYSCTL_XTAL_6_14MHZ</b>, <b>SYSCTL_XTAL_7_37MHZ</b>, <b>SYSCTL_XTAL_8MHZ</b>, <b>SYSCTL_XTAL_8_19MHZ</b>, <b>SYSCTL_XTAL_10MHZ</b>, <b>SYSCTL_XTAL_12MHZ</b>, <b>SYSCTL_XTAL_12_2MHZ</b>, <b>SYSCTL_XTAL_13_5MHZ</b>, <b>SYSCTL_XTAL_14_3MHZ</b>, <b>SYSCTL_XTAL_16MHZ</b>, <b>SYSCTL_XTAL_16_3MHZ</b>, <b>SYSCTL_XTAL_18MHZ</b>, <b>SYSCTL_XTAL_20MHZ</b>, <b>SYSCTL_XTAL_24MHZ</b>, or <b>SYSCTL_XTAL_25MHz</b>. Values below <b>SYSCTL_XTAL_5MHZ</b> are not valid when the PLL is in operation.</p>
<p>The oscillator source is chosen with one of the following values: <b>SYSCTL_OSC_MAIN</b>, <b>SYSCTL_OSC_INT</b>, <b>SYSCTL_OSC_INT4</b>, <b>SYSCTL_OSC_INT30</b>, or <b>SYSCTL_OSC_EXT32</b>. <b>SYSCTL_OSC_EXT32</b> is only available on devices with the hibernate module, and then only when the hibernate module has been enabled.</p>
<p>The internal and main oscillators are disabled with the <b>SYSCTL_INT_OSC_DIS</b> and <b>SYSCTL_MAIN_OSC_DIS</b> flags, respectively. The external oscillator must be enabled in order to use an external clock source. Note that attempts to disable the oscillator used to clock the device is prevented by the hardware.</p>
<p>To clock the system from an external source (such as an external crystal oscillator), use <b>SYSCTL_USE_OSC</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>. To clock the system from the main oscillator, use <b>SYSCTL_USE_OSC</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>. To clock the system from the PLL, use <b>SYSCTL_USE_PLL</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>, and select the appropriate crystal with one of the <b>SYSCTL_XTAL_xxx</b> values.</p>
<dl class="section note"><dt>Note:</dt><dd>If selecting the PLL as the system clock source (that is, via <b>SYSCTL_USE_PLL</b>), this function polls the PLL lock interrupt to determine when the PLL has locked. If an interrupt handler for the system control interrupt is in place, and it responds to and clears the PLL lock interrupt, this function delays until its timeout has occurred instead of completing as soon as PLL lock is achieved.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga618397c50330f5c9d933dcfab2e79e25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlClockSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clocking of the device.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the required configuration of the device clocking.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the clocking of the device. The input crystal frequency, oscillator to be used, use of the PLL, and the system clock divider are all configured with this function.</p>
<p>The <em>ulConfig</em> parameter is the logical OR of several different values, many of which are grouped into sets where only one can be chosen.</p>
<p>The system clock divider is chosen with one of the following values: <b>SYSCTL_SYSDIV_1</b>, <b>SYSCTL_SYSDIV_2</b>, <b>SYSCTL_SYSDIV_3</b>, ... <b>SYSCTL_SYSDIV_64</b>. Only <b>SYSCTL_SYSDIV_1</b> through <b>SYSCTL_SYSDIV_16</b> are valid on Sandstorm-class devices. Half-dividers, such as <b>SYSCTL_SYSDIV_2_5</b> and <b>SYSCTL_SYSDIV_3_5</b>. are available on Tempest-, Firestorm-, and Blizzard-class devices.</p>
<p>The use of the PLL is chosen with either <b>SYSCTL_USE_PLL</b> or <b>SYSCTL_USE_OSC</b>.</p>
<p>The external crystal frequency is chosen with one of the following values: <b>SYSCTL_XTAL_1MHZ</b>, <b>SYSCTL_XTAL_1_84MHZ</b>, <b>SYSCTL_XTAL_2MHZ</b>, <b>SYSCTL_XTAL_2_45MHZ</b>, <b>SYSCTL_XTAL_3_57MHZ</b>, <b>SYSCTL_XTAL_3_68MHZ</b>, <b>SYSCTL_XTAL_4MHZ</b>, <b>SYSCTL_XTAL_4_09MHZ</b>, <b>SYSCTL_XTAL_4_91MHZ</b>, <b>SYSCTL_XTAL_5MHZ</b>, <b>SYSCTL_XTAL_5_12MHZ</b>, <b>SYSCTL_XTAL_6MHZ</b>, <b>SYSCTL_XTAL_6_14MHZ</b>, <b>SYSCTL_XTAL_7_37MHZ</b>, <b>SYSCTL_XTAL_8MHZ</b>, <b>SYSCTL_XTAL_8_19MHZ</b>, <b>SYSCTL_XTAL_10MHZ</b>, <b>SYSCTL_XTAL_12MHZ</b>, <b>SYSCTL_XTAL_12_2MHZ</b>, <b>SYSCTL_XTAL_13_5MHZ</b>, <b>SYSCTL_XTAL_14_3MHZ</b>, <b>SYSCTL_XTAL_16MHZ</b>, <b>SYSCTL_XTAL_16_3MHZ</b>, <b>SYSCTL_XTAL_18MHZ</b>, <b>SYSCTL_XTAL_20MHZ</b>, <b>SYSCTL_XTAL_24MHZ</b>, or <b>SYSCTL_XTAL_25MHz</b>. Values below <b>SYSCTL_XTAL_3_57MHZ</b> are not valid when the PLL is in operation on Sandstorm-, Fury-, Dustdevil-, Tempest-, and Firestorm-class. devices. Values below <b>SYSCTL_XTAL_5MHZ</b> are not valid when the PLL is in operation on Blizzard-class devices. Values below <b>SYSCTL_XTAL_4MHZ</b> are never valid on Blizzard-class devices. On Sandstorm- and Fury-class devices, values above <b>SYSCTL_XTAL_8_19MHZ</b> are not valid. On Dustdevil-, Tempest-, and Firestorm-class devices, values above <b>SYSCTL_XTAL_16_3MHZ</b> are not valid.</p>
<p>The oscillator source is chosen with one of the following values: <b>SYSCTL_OSC_MAIN</b>, <b>SYSCTL_OSC_INT</b>, <b>SYSCTL_OSC_INT4</b>, <b>SYSCTL_OSC_INT30</b>, or <b>SYSCTL_OSC_EXT32</b>. On Sandstorm-class devices, <b>SYSCTL_OSC_INT30</b> and <b>SYSCTL_OSC_EXT32</b> are not valid. <b>SYSCTL_OSC_EXT32</b> is only available on devices with the hibernate module, and then only when the hibernate module has been enabled.</p>
<p>The internal and main oscillators are disabled with the <b>SYSCTL_INT_OSC_DIS</b> and <b>SYSCTL_MAIN_OSC_DIS</b> flags, respectively. The external oscillator must be enabled in order to use an external clock source. Note that attempts to disable the oscillator used to clock the device is prevented by the hardware.</p>
<p>To clock the system from an external source (such as an external crystal oscillator), use <b>SYSCTL_USE_OSC</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>. To clock the system from the main oscillator, use <b>SYSCTL_USE_OSC</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>. To clock the system from the PLL, use <b>SYSCTL_USE_PLL</b> <b></b>| <b>SYSCTL_OSC_MAIN</b>, and select the appropriate crystal with one of the <b>SYSCTL_XTAL_xxx</b> values.</p>
<dl class="section note"><dt>Note:</dt><dd>If selecting the PLL as the system clock source (that is, via <b>SYSCTL_USE_PLL</b>), this function polls the PLL lock interrupt to determine when the PLL has locked. If an interrupt handler for the system control interrupt is in place, and it responds to and clears the PLL lock interrupt, this function delays until its timeout has occurred instead of completing as soon as PLL lock is achieved.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gac54fcca75df0066bd2b2ecdf92c0eda2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the processor into deep-sleep mode.</p>
<p>This function places the processor into deep-sleep mode; it does not return until the processor returns to run mode. The peripherals that are enabled via <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a> continue to operate and can wake up the processor (if automatic clock gating is enabled with <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>, otherwise all peripherals continue to operate).</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga744cd0f180b45ce693702fd074acb1db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleepClockSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clocking of the device while in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required configuration of the device clocking while in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the clocking of the device while in deep-sleep mode. The oscillator to be used and the system clock divider are configured with this function.</p>
<p>The <em>ui32Config</em> parameter is the logical OR of the following values:</p>
<p>The system clock divider is chosen from one of the following values: <b>SYSCTL_DSLP_DIV_1</b>, <b>SYSCTL_DSLP_DIV_2</b>, <b>SYSCTL_DSLP_DIV_3</b>, ... <b>SYSCTL_DSLP_DIV_64</b>.</p>
<p>The oscillator source is chosen from one of the following values: <b>SYSCTL_DSLP_OSC_MAIN</b>, <b>SYSCTL_DSLP_OSC_INT</b>, <b>SYSCTL_DSLP_OSC_INT30</b>, or <b>SYSCTL_DSLP_OSC_EXT32</b>. <b>SYSCTL_OSC_EXT32</b> is only available on devices with the hibernation module, and then only when the hibernation module has been enabled.</p>
<p>The precision internal oscillator can be powered down in deep-sleep mode by specifying <b>SYSCTL_DSLP_PIOSC_PD</b>. The precision internal oscillator is not powered down if it is required for operation while in deep-sleep (based on other configuration settings.) </p>
<dl class="section note"><dt>Note:</dt><dd>The availability of deep-sleep clocking configuration varies with the Tiva part in use. Please consult the data sheet for the part you are using to determine whether this support is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga04b483db497a4cd5d25ef0c34be55b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlDeepSleepClockSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the clocking of the device while in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the required configuration of the device clocking while in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the clocking of the device while in deep-sleep mode. The oscillator to be used and the system clock divider are configured with this function.</p>
<p>The <em>ulConfig</em> parameter is the logical OR of the following values:</p>
<p>The system clock divider is chosen from one of the following values: <b>SYSCTL_DSLP_DIV_1</b>, <b>SYSCTL_DSLP_DIV_2</b>, <b>SYSCTL_DSLP_DIV_3</b>, ... <b>SYSCTL_DSLP_DIV_64</b>.</p>
<p>The oscillator source is chosen from one of the following values: <b>SYSCTL_DSLP_OSC_MAIN</b>, <b>SYSCTL_DSLP_OSC_INT</b>, <b>SYSCTL_DSLP_OSC_INT30</b>, or <b>SYSCTL_DSLP_OSC_EXT32</b>. <b>SYSCTL_OSC_EXT32</b> is only available on devices with the hibernation module, and then only when the hibernation module has been enabled.</p>
<p>The precision internal oscillator can be powered down in deep-sleep mode by specifying <b>SYSCTL_DSLP_PIOSC_PD</b>. The precision internal oscillator is not powered down if it is required for operation while in deep-sleep (based on other configuration settings.)</p>
<dl class="section note"><dt>Note:</dt><dd>The availability of deep-sleep clocking configuration varies with the Stellaris part in use. Please consult the data sheet for the part you are using to determine whether this support is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e91559f5cd697cd17c467ea1003c2d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlFlashSizeGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the flash.</p>
<p>This function determines the size of the flash on the Tiva device.</p>
<dl class="section return"><dt>Returns:</dt><dd>The total number of bytes of flash.</dd></dl>
<p>Gets the size of the flash.</p>
<p>This function determines the size of the flash on the Stellaris device.</p>
<dl class="section return"><dt>Returns:</dt><dd>The total number of bytes of flash. </dd></dl>

</div>
</div>
<a class="anchor" id="ga319195ed040b6d8ddaee3ca5ea562606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlGPIOAHBDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GPIOPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables access to a GPIO peripheral via the AHB.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32GPIOPeripheral</td><td>is the GPIO peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the specified GPIO peripheral for access from the Advanced Host Bus (AHB). Once disabled, the GPIO peripheral is accessed from the legacy Advanced Peripheral Bus (APB).</p>
<p>The <b>ui32GPIOPeripheral</b> argument must be only one of the following values: <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, or <b>SYSCTL_PERIPH_GPIOJ</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>Some devices allow disabling AHB access to GPIO ports that are only present on the AHB. Disabling AHB access to these ports will disable access to these GPIO ports.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga56d5321a5afcf4fe133143ff07731abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlGPIOAHBDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulGPIOPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a GPIO peripheral for access from the AHB.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulGPIOPeripheral</td><td>is the GPIO peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the specified GPIO peripheral for access from the Advanced Host Bus (AHB). Once disabled, the GPIO peripheral is accessed from the legacy Advanced Peripheral Bus (APB).</p>
<p>The <b>ulGPIOPeripheral</b> argument must be only one of the following values: <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, or <b>SYSCTL_PERIPH_GPIOJ</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf2447348f48b339b8e7a73ed5e80afd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlGPIOAHBEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32GPIOPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables access to a GPIO peripheral via the AHB.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32GPIOPeripheral</td><td>is the GPIO peripheral to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to enable the specified GPIO peripheral to be accessed from the Advanced Host Bus (AHB) instead of the legacy Advanced Peripheral Bus (APB). When a GPIO peripheral is enabled for AHB access, the <b>_AHB_BASE</b> form of the base address should be used for GPIO functions. For example, instead of using <b>GPIO_PORTA_BASE</b> as the base address for GPIO functions, use <b>GPIO_PORTA_AHB_BASE</b> instead.</p>
<p>The <em>ui32GPIOPeripheral</em> argument must be only one of the following values: <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, or <b>SYSCTL_PERIPH_GPIOJ</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32e193023cb12193646ab25774789bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlGPIOAHBEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulGPIOPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a GPIO peripheral for access from the AHB.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulGPIOPeripheral</td><td>is the GPIO peripheral to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is used to enable the specified GPIO peripheral to be accessed from the Advanced Host Bus (AHB) instead of the legacy Advanced Peripheral Bus (APB). When a GPIO peripheral is enabled for AHB access, the <b>_AHB_BASE</b> form of the base address should be used for GPIO functions. For example, instead of using <b>GPIO_PORTA_BASE</b> as the base address for GPIO functions, use <b>GPIO_PORTA_AHB_BASE</b> instead.</p>
<p>The <em>ulGPIOPeripheral</em> argument must be only one of the following values: <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, or <b>SYSCTL_PERIPH_GPIOJ</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5bfa1ee7e16f35485e3bc21e7ba6092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlI2SMClkSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInputClock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulMClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the MCLK frequency provided to the I2S module.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulInputClock</td><td>is the input clock to the MCLK divider. If this value is zero, the value is computed from the current PLL configuration. </td></tr>
    <tr><td class="paramname">ulMClk</td><td>is the desired MCLK frequency. If this value is zero, MCLK output is disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the dividers to provide MCLK to the I2S module. A MCLK divider is chosen that produces the MCLK frequency that is the closest possible to the requested frequency, which may be above or below the requested frequency.</p>
<p>The actual MCLK frequency is returned. It is the responsibility of the application to determine if the selected MCLK is acceptable; in general the human ear can not discern the frequency difference if it is within 0.3% of the desired frequency (although there is a very small percentage of the population that can discern lower frequency deviations).</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the actual MCLK frequency. </dd></dl>

</div>
</div>
<a class="anchor" id="gad6c94773880c951cdfe70b387626d081"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified system control interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately upon exit.</p>
<dl class="section note"><dt>Note:</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd>
<dd>
The interrupt sources vary based on the Tiva part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5800d87d0cb3c581a443ba69d4f9ff47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntClear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulInts</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>The specified system control interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately upon exit.</p>
<dl class="section note"><dt>Note:</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd>
<dd>
The interrupt sources vary based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae3131c668931a976c6005d17135693b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be disabled. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Tiva part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f60dde986750017796830ca7339ceef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulInts</td><td>is a bit mask of the interrupt sources to be disabled. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d75a6ab7e4a0d8fb88d7ef9359b2adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Ints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Ints</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Tiva part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0f4f34f6717ae0c41934937d602a53d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual system control interrupt sources.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulInts</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and/or <b>SYSCTL_INT_PLL_FAIL</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated system control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad3caf3c0e7eddea266b7dc2fcb121c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntRegister </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pfnHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the system control interrupt.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the system control interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a system control interrupt occurs. This function enables the global interrupt in the interrupt controller; specific system control interrupts must be enabled via <a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear()</a>.</p>
<p>System control can generate interrupts when the PLL achieves lock, if the internal LDO current limit is exceeded, if the internal oscillator fails, if the main oscillator fails, if the internal LDO output voltage droops too much, if the external voltage droops too much, or if the PLL fails.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>The events that cause system control interrupts vary based on the Tiva part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None.</dd></dl>
<p>Registers an interrupt handler for the system control interrupt.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pfnHandler</td><td>is a pointer to the function to be called when the system control interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a system control interrupt occurs. This function enables the global interrupt in the interrupt controller; specific system control interrupts must be enabled via <a class="el" href="group__sysctl__api.html#ga4d75a6ab7e4a0d8fb88d7ef9359b2adb">SysCtlIntEnable()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__sysctl__api.html#gad6c94773880c951cdfe70b387626d081">SysCtlIntClear()</a>.</p>
<p>System control can generate interrupts when the PLL achieves lock, if the internal LDO current limit is exceeded, if the internal oscillator fails, if the main oscillator fails, if the internal LDO output voltage droops too much, if the external voltage droops too much, or if the PLL fails.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>The events that cause system control interrupts vary based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gab10bfca29c2ba2a5ad80f8c57192ef7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlIntStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMasked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is required and true if the masked interrupt status is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the system controller. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Tiva part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>The current interrupt status, enumerated as a bit field of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and <b>SYSCTL_INT_PLL_FAIL</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga20458dd7afe7fa08e51aea0c3a31526e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlIntStatus </td>
          <td>(</td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bMasked</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bMasked</td><td>is false if the raw interrupt status is required and true if the masked interrupt status is required.</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the interrupt status for the system controller. Either the raw interrupt status or the status of interrupts that are allowed to reflect to the processor can be returned.</p>
<dl class="section return"><dt>Returns:</dt><dd>The current interrupt status, enumerated as a bit field of <b>SYSCTL_INT_PLL_LOCK</b>, <b>SYSCTL_INT_CUR_LIMIT</b>, <b>SYSCTL_INT_IOSC_FAIL</b>, <b>SYSCTL_INT_MOSC_FAIL</b>, <b>SYSCTL_INT_POR</b>, <b>SYSCTL_INT_BOR</b>, and <b>SYSCTL_INT_PLL_FAIL</b>.</dd></dl>
<dl class="section note"><dt>Note:</dt><dd>The interrupt sources vary based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ga96fa0579c653617672244b6a280d9897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIntUnregister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the system control interrupt.</p>
<p>This function unregisters the handler to be called when a system control interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="group__interrupt__api.html#ga0a32aafea7f4904d2a64ee18b45f96c9">IntRegister()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba87ddb0c7b406bab3d21976d7870a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlIOSCVerificationSet </td>
          <td>(</td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the internal oscillator verification timer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the internal oscillator verification timer should be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the internal oscillator verification timer to be enabled or disabled. When enabled, an interrupt is generated if the internal oscillator ceases to operate.</p>
<p>The internal oscillator verification timer is only available on Sandstorm-class devices.</p>
<dl class="section note"><dt>Note:</dt><dd>Both oscillators (main and internal) must be enabled for this verification timer to operate as the main oscillator verifies the internal oscillator.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gadee84f864ab925d0408c35fd9ecc1f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlLDOConfigSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the LDO failure control.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the required LDO failure control setting; can be either <b>SYSCTL_LDOCFG_ARST</b> or <b>SYSCTL_LDOCFG_NORST</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the LDO to be configured to cause a processor reset when the output voltage becomes unregulated.</p>
<p>The LDO failure control is only available on Sandstorm-class devices.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2ff010082d26add6df27b893714e019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlLDOGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the output voltage of the LDO.</p>
<p>This function determines the output voltage of the LDO, as specified by the control register.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the current voltage of the LDO and is one of: <b>SYSCTL_LDO_2_25V</b>, <b>SYSCTL_LDO_2_30V</b>, <b>SYSCTL_LDO_2_35V</b>, <b>SYSCTL_LDO_2_40V</b>, <b>SYSCTL_LDO_2_45V</b>, <b>SYSCTL_LDO_2_50V</b>, <b>SYSCTL_LDO_2_55V</b>, <b>SYSCTL_LDO_2_60V</b>, <b>SYSCTL_LDO_2_65V</b>, <b>SYSCTL_LDO_2_70V</b>, or <b>SYSCTL_LDO_2_75V</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga371e823da4cd004df3517874781674e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlLDOSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulVoltage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the output voltage of the LDO.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulVoltage</td><td>is the required output voltage from the LDO.</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets the output voltage of the LDO. The <em>ulVoltage</em> parameter specifies the LDO voltage and must be one of the following values: <b>SYSCTL_LDO_2_25V</b>, <b>SYSCTL_LDO_2_30V</b>, <b>SYSCTL_LDO_2_35V</b>, <b>SYSCTL_LDO_2_40V</b>, <b>SYSCTL_LDO_2_45V</b>, <b>SYSCTL_LDO_2_50V</b>, <b>SYSCTL_LDO_2_55V</b>, <b>SYSCTL_LDO_2_60V</b>, <b>SYSCTL_LDO_2_65V</b>, <b>SYSCTL_LDO_2_70V</b>, or <b>SYSCTL_LDO_2_75V</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The default LDO voltage and the adjustment range varies with the Stellaris part in use. Please consult the data sheet for the part you are using to determine the default voltage and range available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5ea49a00d023774f052fc53a2ccb953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlMOSCConfigSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a small delay.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Count</td><td>is the number of delay loop iterations to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides a means of generating a constant length delay. It is written in assembly to keep the delay consistent across tool chains, avoiding the need to tune the delay based on the tool chain in use.</p>
<p>The loop takes 3 cycles/loop.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. Sets the configuration of the main oscillator (MOSC) control.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the required configuration of the MOSC control.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the control of the main oscillator. The <em>ui32Config</em> is specified as the logical OR of the following values:</p>
<ul>
<li><b>SYSCTL_MOSC_VALIDATE</b> enables the MOSC verification circuit that detects a failure of the main oscillator (such as a loss of the clock).</li>
<li><b>SYSCTL_MOSC_INTERRUPT</b> indicates that a MOSC failure should generate an interrupt instead of resetting the processor.</li>
<li><b>SYSCTL_MOSC_NO_XTAL</b> indicates that there is no crystal connected to the OSC0/OSC1 pins, allowing power consumption to be reduced.</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd>The availability of MOSC control varies based on the Tiva part in use. Please consult the data sheet for the part you are using to determine whether this support is available. In addition, the capability of MOSC control varies based on the Tiva part in use.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89317ff4273dea216f78ad66bfc9e87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlMOSCConfigSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a small delay.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulCount</td><td>is the number of delay loop iterations to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides a means of generating a constant length delay. It is written in assembly to keep the delay consistent across tool chains, avoiding the need to tune the delay based on the tool chain in use.</p>
<p>The loop takes 3 cycles/loop.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. Sets the configuration of the main oscillator (MOSC) control.</dd></dl>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the required configuration of the MOSC control.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the control of the main oscillator. The <em>ulConfig</em> is specified as follows:</p>
<ul>
<li><b>SYSCTL_MOSC_VALIDATE</b> enables the MOSC verification circuit that detects a failure of the main oscillator (such as a loss of the clock).</li>
<li><b>SYSCTL_MOSC_INTERRUPT</b> indicates that a MOSC failure should generate an interrupt instead of resetting the processor.</li>
<li><b>SYSCTL_MOSC_NO_XTAL</b> indicates that there is no crystal connected to the OSC0/OSC1 pins, allowing power consumption to be reduced.</li>
</ul>
<dl class="section note"><dt>Note:</dt><dd>The availability of MOSC control varies based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine whether this support is available. In addition, the capability of MOSC control varies based on the Stellaris part in use.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga588eb8fcecf50ef0c7a051db102dfcaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlMOSCVerificationSet </td>
          <td>(</td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the main oscillator verification timer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the main oscillator verification timer should be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the main oscillator verification timer to be enabled or disabled. When enabled, an interrupt is generated if the main oscillator ceases to operate.</p>
<p>The main oscillator verification timer is only available on Sandstorm-class devices.</p>
<dl class="section note"><dt>Note:</dt><dd>Both oscillators (main and internal) must be enabled for this verification timer to operate as the internal oscillator verifies the main oscillator.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ad7b6dcec84339f2bbb8663551cc7d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralClockGating </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls peripheral clock gating in sleep and deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the sleep and deep-sleep peripheral configuration should be used and <b>false</b> if not.</td></tr>
  </table>
  </dd>
</dl>
<p>This function controls how peripherals are clocked when the processor goes into sleep or deep-sleep mode. By default, the peripherals are clocked the same as in run mode; if peripheral clock gating is enabled, they are clocked according to the configuration set by <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a>, <a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable()</a>, <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a>, and <a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable()</a>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d308b9f15c38733fb3b3b702b821324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralClockGating </td>
          <td>(</td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls peripheral clock gating in sleep and deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the sleep and deep-sleep peripheral configuration should be used and <b>false</b> if not.</td></tr>
  </table>
  </dd>
</dl>
<p>This function controls how peripherals are clocked when the processor goes into sleep or deep-sleep mode. By default, the peripherals are clocked the same as in run mode; if peripheral clock gating is enabled, they are clocked according to the configuration set by <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a>, <a class="el" href="group__sysctl__api.html#gaa1131a3d12965af7cdaa02f0649dc237">SysCtlPeripheralSleepDisable()</a>, <a class="el" href="group__sysctl__api.html#gad412f63e83618b3085f324778b1fd606">SysCtlPeripheralDeepSleepEnable()</a>, and <a class="el" href="group__sysctl__api.html#ga8f46fff4f83f6e6771b9839fe58d209a">SysCtlPeripheralDeepSleepDisable()</a>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f46fff4f83f6e6771b9839fe58d209a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into deep-sleep mode. Disabling peripherals while in deep-sleep mode helps to lower the current draw of the device, and can keep peripherals that require a particular clock frequency from operating when the clock changes as a result of entering deep-sleep mode. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves deep-sleep mode, maintaining its entire state from before deep-sleep mode was entered.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb5e6b7ec4ef56efce1a2f878c1057fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to disable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into deep-sleep mode. Disabling peripherals while in deep-sleep mode helps to lower the current draw of the device, and can keep peripherals that require a particular clock frequency from operating when the clock changes as a result of entering deep-sleep mode. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves deep-sleep mode, maintaining its entire state from before deep-sleep mode was entered.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad412f63e83618b3085f324778b1fd606"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into deep-sleep mode. Because the clocking configuration of the device may change, not all peripherals can safely continue operating while the processor is in deep-sleep mode. Those that must run at a particular frequency (such as a UART) do not work as expected if the clock changes. It is the responsibility of the caller to make sensible choices.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga01e3073f0a62b957ace580b48bbb225f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDeepSleepEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in deep-sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to enable in deep-sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into deep-sleep mode. Because the clocking configuration of the device may change, not all peripherals can safely continue operating while the processor is in sleep mode. Those that must run at a particular frequency (such as a UART) do not work as expected if the clock changes. It is the responsibility of the caller to make sensible choices.</p>
<p>Deep-sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral deep-sleep mode configuration is maintained but has no effect when deep-sleep mode is entered.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41000fce023961157e6031ac94ff1f3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables a peripheral. Once disabled, they do not operate or respond to register reads/writes.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c6ae288a5a775030ec42032f98b5ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to disable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables peripherals are disabled with this function. Once disabled, they do not operate or respond to register reads/writes.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fbae61db465e1d861a62785d28e3ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables a peripheral. At power-up, all peripherals are disabled; they must be enabled in order to operate or respond to register reads/writes.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>It takes five clock cycles after the write to enable a peripheral before the the peripheral is actually enabled. During this time, attempts to access the peripheral result in a bus fault. Care should be taken to ensure that the peripheral is not accessed during this brief time period.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gabe04fe3c0a202f2b2c12945523a8003b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to enable.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables peripherals. At power-up, all peripherals are disabled; they must be enabled in order to operate or respond to register reads/writes.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>It takes five clock cycles after the write to enable a peripheral before the the peripheral is actually enabled. During this time, attempts to access the peripheral result in a bus fault. Care should be taken to ensure that the peripheral is not accessed during this brief time period.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga18c4cbb616f0b37b806914543e2a09b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOff </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers off a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to be powered off.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the power to a peripheral to be turned off. The peripheral continues to receive power when its clock is enabled, but the power is removed when its clock is disabled.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to power off a peripheral varies based on the Tiva part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a74275e3ee4077a4ff11ce8d8363de6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOff </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers off a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to be powered off.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the power to a peripheral to be turned off. The peripheral continues to receive power when its clock is enabled, but the power is removed when its clock is disabled.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to power off a peripheral varies based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cf69aace5f096e92b7908fbe5e7fdc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOn </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers on a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to be powered on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function turns on the power to a peripheral. The peripheral continues to receive power even when its clock is not enabled.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to power off a peripheral varies based on the Tiva part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea8b8285a15845064a909e77f30a0c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralPowerOn </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers on a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to be powered on.</td></tr>
  </table>
  </dd>
</dl>
<p>This function turns on the power to a peripheral. The peripheral continues to receive power even when its clock is not enabled.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to power off a peripheral varies based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b1d6a1177370abf4bdda1bdf49236c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SysCtlPeripheralPresent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is present.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is present in the device. Each member of the Tiva family has a different peripheral set; this function determines which peripherals are present on this device.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>,</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if the specified peripheral is present and <b>false</b> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga563015090350777d6781e622d6f41b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBoolean SysCtlPeripheralPresent </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is present.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is present in the device. Each member of the Stellaris family has a different peripheral set; this function determines which peripherals are present on this device.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_IEEE1588</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_MPU</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PLL</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TEMP</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>,</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if the specified peripheral is present and <b>false</b> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ddf1f06376894c31e5596f562c299ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SysCtlPeripheralReady </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is ready.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is ready to be accessed. The peripheral may be in a non-ready state if it is not enabled, is being held in reset, or is in the process of becoming ready after being enabled or taken out of reset.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to check for a peripheral being ready varies based on the Tiva part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if the specified peripheral is ready and <b>false</b> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="gad09146a19c9e7a73768e68c363cf1ead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBoolean SysCtlPeripheralReady </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a peripheral is ready.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular peripheral is ready to be accessed. The peripheral may be in a non-ready state if it is not enabled, is being held in reset, or is in the process of becoming ready after being enabled or taken out of reset.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section note"><dt>Note:</dt><dd>The ability to check for a peripheral being ready varies based on the Stellaris part in use. Please consult the data sheet for the part you are using to determine if this feature is available.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if the specified peripheral is ready and <b>false</b> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8c537abe40caacd5dfa7ffdedefb6b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralReset </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a software reset of a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a software reset of the specified peripheral. An individual peripheral reset signal is asserted for a brief period and then de-asserted, returning the internal state of the peripheral to its reset condition.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9d110072f28bc077c022ae393026e198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralReset </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a software reset of a peripheral.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to reset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a software reset of the specified peripheral. An individual peripheral reset signal is asserted for a brief period and then de-asserted, returning the internal state of the peripheral to its reset condition.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1131a3d12965af7cdaa02f0649dc237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to disable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into sleep mode. Disabling peripherals while in sleep mode helps to lower the current draw of the device. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves sleep mode, maintaining its entire state from before sleep mode was entered.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fa1e488302b32666771970252e82964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepDisable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to disable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function causes a peripheral to stop operating when the processor goes into sleep mode. Disabling peripherals while in sleep mode helps to lower the current draw of the device. If enabled (via <a class="el" href="group__sysctl__api.html#ga2fbae61db465e1d861a62785d28e3ad6">SysCtlPeripheralEnable()</a>), the peripheral automatically resumes operation when the processor leaves sleep mode, maintaining its entire state from before sleep mode was entered.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88db79b809decde9d228ee2c3e58a727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Peripheral</td><td>is the peripheral to enable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into sleep mode. Because the clocking configuration of the device does not change, any peripheral can safely continue operating while the processor is in sleep mode and can therefore wake the processor from sleep mode.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ui32Peripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2284e21081949f00e226c6a54bc32ac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPeripheralSleepEnable </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPeripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables a peripheral in sleep mode.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPeripheral</td><td>is the peripheral to enable in sleep mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows a peripheral to continue operating when the processor goes into sleep mode. Because the clocking configuration of the device does not change, any peripheral can safely continue operating while the processor is in sleep mode and can therefore wake the processor from sleep mode.</p>
<p>Sleep mode clocking of peripherals must be enabled via <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>; if disabled, the peripheral sleep mode configuration is maintained but has no effect when sleep mode is entered.</p>
<p>The <em>ulPeripheral</em> parameter must be only one of the following values: <b>SYSCTL_PERIPH_ADC0</b>, <b>SYSCTL_PERIPH_ADC1</b>, <b>SYSCTL_PERIPH_CAN0</b>, <b>SYSCTL_PERIPH_CAN1</b>, <b>SYSCTL_PERIPH_CAN2</b>, <b>SYSCTL_PERIPH_COMP0</b>, <b>SYSCTL_PERIPH_COMP1</b>, <b>SYSCTL_PERIPH_COMP2</b>, <b>SYSCTL_PERIPH_EEPROM0</b>, <b>SYSCTL_PERIPH_EPI0</b>, <b>SYSCTL_PERIPH_ETH</b>, <b>SYSCTL_PERIPH_FAN0</b>, <b>SYSCTL_PERIPH_GPIOA</b>, <b>SYSCTL_PERIPH_GPIOB</b>, <b>SYSCTL_PERIPH_GPIOC</b>, <b>SYSCTL_PERIPH_GPIOD</b>, <b>SYSCTL_PERIPH_GPIOE</b>, <b>SYSCTL_PERIPH_GPIOF</b>, <b>SYSCTL_PERIPH_GPIOG</b>, <b>SYSCTL_PERIPH_GPIOH</b>, <b>SYSCTL_PERIPH_GPIOJ</b>, <b>SYSCTL_PERIPH_GPIOK</b>, <b>SYSCTL_PERIPH_GPIOL</b>, <b>SYSCTL_PERIPH_GPIOM</b>, <b>SYSCTL_PERIPH_GPION</b>, <b>SYSCTL_PERIPH_GPIOP</b>, <b>SYSCTL_PERIPH_GPIOQ</b>, <b>SYSCTL_PERIPH_HIBERNATE</b>, <b>SYSCTL_PERIPH_I2C0</b>, <b>SYSCTL_PERIPH_I2C1</b>, <b>SYSCTL_PERIPH_I2C2</b>, <b>SYSCTL_PERIPH_I2C3</b>, <b>SYSCTL_PERIPH_I2C4</b>, <b>SYSCTL_PERIPH_I2C5</b>, <b>SYSCTL_PERIPH_I2S0</b>, <b>SYSCTL_PERIPH_LPC0</b>, <b>SYSCTL_PERIPH_PECI0</b>, <b>SYSCTL_PERIPH_PWM0</b>, <b>SYSCTL_PERIPH_PWM1</b>, <b>SYSCTL_PERIPH_QEI0</b>, <b>SYSCTL_PERIPH_QEI1</b>, <b>SYSCTL_PERIPH_SSI0</b>, <b>SYSCTL_PERIPH_SSI1</b>, <b>SYSCTL_PERIPH_SSI2</b>, <b>SYSCTL_PERIPH_SSI3</b>, <b>SYSCTL_PERIPH_TIMER0</b>, <b>SYSCTL_PERIPH_TIMER1</b>, <b>SYSCTL_PERIPH_TIMER2</b>, <b>SYSCTL_PERIPH_TIMER3</b>, <b>SYSCTL_PERIPH_TIMER4</b>, <b>SYSCTL_PERIPH_TIMER5</b>, <b>SYSCTL_PERIPH_UART0</b>, <b>SYSCTL_PERIPH_UART1</b>, <b>SYSCTL_PERIPH_UART2</b>, <b>SYSCTL_PERIPH_UART3</b>, <b>SYSCTL_PERIPH_UART4</b>, <b>SYSCTL_PERIPH_UART5</b>, <b>SYSCTL_PERIPH_UART6</b>, <b>SYSCTL_PERIPH_UART7</b>, <b>SYSCTL_PERIPH_UDMA</b>, <b>SYSCTL_PERIPH_USB0</b>, <b>SYSCTL_PERIPH_WDOG0</b>, <b>SYSCTL_PERIPH_WDOG1</b>, <b>SYSCTL_PERIPH_WTIMER0</b>, <b>SYSCTL_PERIPH_WTIMER1</b>, <b>SYSCTL_PERIPH_WTIMER2</b>, <b>SYSCTL_PERIPH_WTIMER3</b>, <b>SYSCTL_PERIPH_WTIMER4</b>, or <b>SYSCTL_PERIPH_WTIMER5</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2880e79802ff713958523e026a9e045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tBoolean SysCtlPinPresent </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if a pin is present.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulPin</td><td>is the pin in question.</td></tr>
  </table>
  </dd>
</dl>
<p>This function determines if a particular pin is present in the device. The PWM, analog comparators, ADC, and timers have a varying number of pins across members of the Stellaris family; this function determines which pins are present on this device.</p>
<p>The <em>ulPin</em> argument must be only one of the following values: <b>SYSCTL_PIN_PWM0</b>, <b>SYSCTL_PIN_PWM1</b>, <b>SYSCTL_PIN_PWM2</b>, <b>SYSCTL_PIN_PWM3</b>, <b>SYSCTL_PIN_PWM4</b>, <b>SYSCTL_PIN_PWM5</b>, <b>SYSCTL_PIN_C0MINUS</b>, <b>SYSCTL_PIN_C0PLUS</b>, <b>SYSCTL_PIN_C0O</b>, <b>SYSCTL_PIN_C1MINUS</b>, <b>SYSCTL_PIN_C1PLUS</b>, <b>SYSCTL_PIN_C1O</b>, <b>SYSCTL_PIN_C2MINUS</b>, <b>SYSCTL_PIN_C2PLUS</b>, <b>SYSCTL_PIN_C2O</b>, <b>SYSCTL_PIN_ADC0</b>, <b>SYSCTL_PIN_ADC1</b>, <b>SYSCTL_PIN_ADC2</b>, <b>SYSCTL_PIN_ADC3</b>, <b>SYSCTL_PIN_ADC4</b>, <b>SYSCTL_PIN_ADC5</b>, <b>SYSCTL_PIN_ADC6</b>, <b>SYSCTL_PIN_ADC7</b>, <b>SYSCTL_PIN_CCP0</b>, <b>SYSCTL_PIN_CCP1</b>, <b>SYSCTL_PIN_CCP2</b>, <b>SYSCTL_PIN_CCP3</b>, <b>SYSCTL_PIN_CCP4</b>, <b>SYSCTL_PIN_CCP5</b>, <b>SYSCTL_PIN_CCP6</b>, <b>SYSCTL_PIN_CCP7</b>, <b>SYSCTL_PIN_32KHZ</b>, or <b>SYSCTL_PIN_MC_FAULT0</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <b>true</b> if the specified pin is present and <b>false</b> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5bd79f60945f405c34c89005b0eb50d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SysCtlPIOSCCalibrate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calibrates the precision internal oscillator.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Type</td><td>is the type of calibration to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a calibration of the PIOSC. There are three types of calibration available; the desired calibration type as specified in <em>ui32Type</em> is one of:</p>
<ul>
<li><b>SYSCTL_PIOSC_CAL_AUTO</b> to perform automatic calibration using the 32-kHz clock from the hibernate module as a reference. This type is only possible on parts that have a hibernate module, and then only if it is enabled and the hibernate module's RTC is also enabled.</li>
</ul>
<ul>
<li><b>SYSCTL_PIOSC_CAL_FACT</b> to reset the PIOSC calibration to the factory provided calibration.</li>
</ul>
<ul>
<li><b>SYSCTL_PIOSC_CAL_USER</b> to set the PIOSC calibration to a user-supplied value. The value to be used is ORed into the lower 7-bits of this value, with 0x40 being the ``nominal'' value (in other words, if everything were perfect, 0x40 provides exactly 16 MHz). Values larger than 0x40 slow down PIOSC, and values smaller than 0x40 speed up PIOSC.</li>
</ul>
<dl class="section return"><dt>Returns:</dt><dd>Returns 1 if the calibration was successful and 0 if it failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga061185206da3937dde5c93b03b325579"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlPIOSCCalibrate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calibrates the precision internal oscillator.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulType</td><td>is the type of calibration to perform.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a calibration of the PIOSC. There are three types of calibration available; the desired calibration type as specified in <em>ulType</em> is one of:</p>
<ul>
<li><b>SYSCTL_PIOSC_CAL_AUTO</b> to perform automatic calibration using the 32-kHz clock from the hibernate module as a reference. This type is only possible on parts that have a hibernate module, and then only if it is enabled and the hibernate module's RTC is also enabled.</li>
</ul>
<ul>
<li><b>SYSCTL_PIOSC_CAL_FACT</b> to reset the PIOSC calibration to the factory provided calibration.</li>
</ul>
<ul>
<li><b>SYSCTL_PIOSC_CAL_USER</b> to set the PIOSC calibration to a user-supplied value. The value to be used is ORed into the lower 7-bits of this value, with 0x40 being the ``nominal'' value (in other words, if everything were perfect, 0x40 provides exactly 16 MHz). Values larger than 0x40 slow down PIOSC, and values smaller than 0x40 speed up PIOSC.</li>
</ul>
<dl class="section return"><dt>Returns:</dt><dd>Returns 1 if the calibration was successful and 0 if it failed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga596bd847d8e275d44af2998fcaa70f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPLLVerificationSet </td>
          <td>(</td>
          <td class="paramtype">tBoolean&#160;</td>
          <td class="paramname"><em>bEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the PLL verification timer.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bEnable</td><td>is a boolean that is <b>true</b> if the PLL verification timer should be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>This function allows the PLL verification timer to be enabled or disabled. When enabled, an interrupt is generated if the PLL ceases to operate.</p>
<p>The PLL verification timer is only available on Sandstorm-class devices.</p>
<dl class="section note"><dt>Note:</dt><dd>The main oscillator must be enabled for this verification timer to operate as it is used to check the PLL. Also, the verification timer should be disabled while the PLL is being reconfigured via <a class="el" href="group__sysctl__api.html#gab9c9f4e4588e1e9c5b42e3c3b109e5c1">SysCtlClockSet()</a>.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cad830172c4c26ebe550bec5cc63250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlPWMClockGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current PWM clock configuration.</p>
<p>This function returns the current PWM clock configuration.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the current PWM clock configuration; is one of <b>SYSCTL_PWMDIV_1</b>, <b>SYSCTL_PWMDIV_2</b>, <b>SYSCTL_PWMDIV_4</b>, <b>SYSCTL_PWMDIV_8</b>, <b>SYSCTL_PWMDIV_16</b>, <b>SYSCTL_PWMDIV_32</b>, or <b>SYSCTL_PWMDIV_64</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga444e7a242f14e945fcc7a909d13d2d3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPWMClockSet </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PWM clock configuration.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Config</td><td>is the configuration for the PWM clock; it must be one of <b>SYSCTL_PWMDIV_1</b>, <b>SYSCTL_PWMDIV_2</b>, <b>SYSCTL_PWMDIV_4</b>, <b>SYSCTL_PWMDIV_8</b>, <b>SYSCTL_PWMDIV_16</b>, <b>SYSCTL_PWMDIV_32</b>, or <b>SYSCTL_PWMDIV_64</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the rate of the clock provided to the PWM module as a ratio of the processor clock. This clock is used by the PWM module to generate PWM signals; its rate forms the basis for all PWM signals.</p>
<dl class="section note"><dt>Note:</dt><dd>The clocking of the PWM is dependent upon the system clock rate as configured by <a class="el" href="group__sysctl__api.html#gab9c9f4e4588e1e9c5b42e3c3b109e5c1">SysCtlClockSet()</a>.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc14db980db9176f65f182e3038d890a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlPWMClockSet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the PWM clock configuration.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulConfig</td><td>is the configuration for the PWM clock; it must be one of <b>SYSCTL_PWMDIV_1</b>, <b>SYSCTL_PWMDIV_2</b>, <b>SYSCTL_PWMDIV_4</b>, <b>SYSCTL_PWMDIV_8</b>, <b>SYSCTL_PWMDIV_16</b>, <b>SYSCTL_PWMDIV_32</b>, or <b>SYSCTL_PWMDIV_64</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function configures the rate of the clock provided to the PWM module as a ratio of the processor clock. This clock is used by the PWM module to generate PWM signals; its rate forms the basis for all PWM signals.</p>
<dl class="section note"><dt>Note:</dt><dd>The clocking of the PWM is dependent upon the system clock rate as configured by <a class="el" href="group__sysctl__api.html#gab9c9f4e4588e1e9c5b42e3c3b109e5c1">SysCtlClockSet()</a>.</dd></dl>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e7eaf3273efa935f7bedfd3760d11b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the device.</p>
<p>This function performs a software reset of the entire device. The processor and all peripherals are reset and all device registers are returned to their default values (with the exception of the reset cause register, which maintains its current value but has the software reset bit set as well).</p>
<dl class="section return"><dt>Returns:</dt><dd>This function does not return. </dd></dl>

</div>
</div>
<a class="anchor" id="gab9735274e5c9468bb55ecde9ca07bfb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlResetCauseClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ui32Causes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears reset reasons.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui32Causes</td><td>are the reset causes to be cleared; must be a logical OR of <b>SYSCTL_CAUSE_LDO</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified sticky reset reasons. Once cleared, another reset for the same reason can be detected, and a reset for a different reason can be distinguished (instead of having two reset causes set). If the reset reason is used by an application, all reset causes should be cleared after they are retrieved with <a class="el" href="group__sysctl__api.html#ga7db50d4000d8905c341d79bd75fcc9bb">SysCtlResetCauseGet()</a>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4acd3ca031af59e42f84fbbd704aa6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlResetCauseClear </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulCauses</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears reset reasons.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulCauses</td><td>are the reset causes to be cleared; must be a logical OR of <b>SYSCTL_CAUSE_LDO</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function clears the specified sticky reset reasons. Once cleared, another reset for the same reason can be detected, and a reset for a different reason can be distinguished (instead of having two reset causes set). If the reset reason is used by an application, all reset causes should be cleared after they are retrieved with <a class="el" href="group__sysctl__api.html#ga7db50d4000d8905c341d79bd75fcc9bb">SysCtlResetCauseGet()</a>.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7db50d4000d8905c341d79bd75fcc9bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlResetCauseGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the reason for a reset.</p>
<p>This function returns the reason(s) for a reset. Because the reset reasons are sticky until either cleared by software or a power-on reset, multiple reset reasons may be returned if multiple resets have occurred. The reset reason is a logical OR of <b>SYSCTL_CAUSE_LDO</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the reason(s) for a reset.</dd></dl>
<p>Gets the reason for a reset.</p>
<p>This function returns the reason(s) for a reset. Because the reset reasons are sticky until either cleared by software or an external reset (for Sandstorm-class devices) or a power-on reset (for all other classes), multiple reset reasons may be returned if multiple resets have occurred. The reset reason is a logical OR of <b>SYSCTL_CAUSE_LDO</b>, <b>SYSCTL_CAUSE_SW</b>, <b>SYSCTL_CAUSE_WDOG</b>, <b>SYSCTL_CAUSE_BOR</b>, <b>SYSCTL_CAUSE_POR</b>, and/or <b>SYSCTL_CAUSE_EXT</b>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the reason(s) for a reset. </dd></dl>

</div>
</div>
<a class="anchor" id="ga90efcbaddc41095b9567cae626aaeb2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlSleep </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Puts the processor into sleep mode.</p>
<p>This function places the processor into sleep mode; it does not return until the processor returns to run mode. The peripherals that are enabled via <a class="el" href="group__sysctl__api.html#ga88db79b809decde9d228ee2c3e58a727">SysCtlPeripheralSleepEnable()</a> continue to operate and can wake up the processor (if automatic clock gating is enabled with <a class="el" href="group__sysctl__api.html#ga0ad7b6dcec84339f2bbb8663551cc7d8">SysCtlPeripheralClockGating()</a>, otherwise all peripherals continue to operate).</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga885c5d8317952b063d39c8291981e499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long SysCtlSRAMSizeGet </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the SRAM.</p>
<p>This function determines the size of the SRAM on the Tiva device.</p>
<dl class="section return"><dt>Returns:</dt><dd>The total number of bytes of SRAM.</dd></dl>
<p>Gets the size of the SRAM.</p>
<p>This function determines the size of the SRAM on the Stellaris device.</p>
<dl class="section return"><dt>Returns:</dt><dd>The total number of bytes of SRAM. </dd></dl>

</div>
</div>
<a class="anchor" id="ga980dda99cd999c319351c2c24992d9a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlUSBPLLDisable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers down the USB PLL.</p>
<p>This function disables the USB controller's PLL, which is used by its physical layer. The USB registers are still accessible, but the physical layer no longer functions.</p>
<dl class="section return"><dt>Returns:</dt><dd>None.</dd></dl>
<p>Powers down the USB PLL.</p>
<p>This function disables the USB controller's PLL, which is used by it's physical layer. The USB registers are still accessible, but the physical layer no longer functions.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9af839cfa9e1635c3d437b7f466c0e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SysCtlUSBPLLEnable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Powers up the USB PLL.</p>
<p>This function enables the USB controller's PLL, which is used by its physical layer. This call is necessary before connecting to any external devices.</p>
<dl class="section return"><dt>Returns:</dt><dd>None.</dd></dl>
<p>Powers up the USB PLL.</p>
<p>This function enables the USB controller's PLL, which is used by it's physical layer. This call is necessary before connecting to any external devices.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 22 2014 11:10:34 for Zigbee Module Examples by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
