<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Zigbee Module Examples: Ustdlib_api</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Module Examples
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Ustdlib_api</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt_time.html">tTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure that contains the broken down date and time.  <a href="structt_time.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab49bf5cb17ebc95be3a294c502114ee1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gab49bf5cb17ebc95be3a294c502114ee1">ustrncpy</a> (char *restrict s1, const char *restrict s2, size_t n)</td></tr>
<tr class="memitem:ga4bfcb7b1819600ed85bee4da3cca530c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga4bfcb7b1819600ed85bee4da3cca530c">uvsnprintf</a> (char *restrict s, size_t n, const char *restrict format, va_list arg)</td></tr>
<tr class="memitem:ga5a47a964e1389c02987481ded1c48138"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga5a47a964e1389c02987481ded1c48138">usprintf</a> (char *restrict s, const char *format,...)</td></tr>
<tr class="memitem:ga09b6644d4db11375176cb8cc8598c4e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga09b6644d4db11375176cb8cc8598c4e5">usnprintf</a> (char *restrict s, size_t n, const char *restrict format,...)</td></tr>
<tr class="memitem:ga3a5728f0b62a5c92bc34f0a41c33278c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga3a5728f0b62a5c92bc34f0a41c33278c">ulocaltime</a> (time_t timer, struct tm *tm)</td></tr>
<tr class="memitem:gaaf70d2ea7909ed1600710c2113c84907"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaaf70d2ea7909ed1600710c2113c84907">umktime</a> (struct tm *timeptr)</td></tr>
<tr class="memitem:gaa6706f6aaf67c3370800e25b6ae1887d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaa6706f6aaf67c3370800e25b6ae1887d">ustrtoul</a> (const char *restrict nptr, const char **restrict endptr, int base)</td></tr>
<tr class="memitem:ga7c1f1d61220c492f777a3f25fd34df3a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga7c1f1d61220c492f777a3f25fd34df3a">ustrtof</a> (const char *nptr, const char **endptr)</td></tr>
<tr class="memitem:ga5bfaf237cc58e9d7cdc51f18e515d585"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga5bfaf237cc58e9d7cdc51f18e515d585">ustrlen</a> (const char *s)</td></tr>
<tr class="memitem:gadb47869995960c31c95f08a400882e3f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gadb47869995960c31c95f08a400882e3f">ustrstr</a> (const char *s1, const char *s2)</td></tr>
<tr class="memitem:ga0085d1d81c8d1570a12a02d3b6ffface"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga0085d1d81c8d1570a12a02d3b6ffface">ustrncasecmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="memitem:gacb9ef59ae11aae4f0169fb3dab34d2d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gacb9ef59ae11aae4f0169fb3dab34d2d6">ustrcasecmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="memitem:gad21ed7429e68621153a72a7230a6a077"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gad21ed7429e68621153a72a7230a6a077">ustrncmp</a> (const char *s1, const char *s2, size_t n)</td></tr>
<tr class="memitem:gaee3790eee84161a4ea17657fe464e8ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaee3790eee84161a4ea17657fe464e8ab">ustrcmp</a> (const char *s1, const char *s2)</td></tr>
<tr class="memitem:gaaecc415a64e9bc2cce10f03eb7a6b753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gaaecc415a64e9bc2cce10f03eb7a6b753">usrand</a> (unsigned int seed)</td></tr>
<tr class="memitem:ga04408b1c80a2190c4aad7b783b5af8d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand</a> (void)</td></tr>
<tr class="memitem:ga5ac4d97f96bc5f98116d1baa82f12b32"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga5ac4d97f96bc5f98116d1baa82f12b32">ustrncpy</a> (char *pcDst, const char *pcSrc, int iNum)</td></tr>
<tr class="memitem:gad3b713ceeb82516ed0373e7d4343d6e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#gad3b713ceeb82516ed0373e7d4343d6e9">uvsnprintf</a> (char *pcBuf, unsigned long ulSize, const char *pcString, va_list vaArgP)</td></tr>
<tr class="memitem:ga8d8940f65bf237f422d3a63312942a10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga8d8940f65bf237f422d3a63312942a10">usprintf</a> (char *pcBuf, const char *pcString,...)</td></tr>
<tr class="memitem:ga0523e2ba8a83e7cfc76be3caaf37b25a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga0523e2ba8a83e7cfc76be3caaf37b25a">usnprintf</a> (char *pcBuf, unsigned long ulSize, const char *pcString,...)</td></tr>
<tr class="memitem:ga06502f734fc4ece2a831fa0046c528bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga06502f734fc4ece2a831fa0046c528bc">ulocaltime</a> (unsigned long ulTime, <a class="el" href="structt_time.html">tTime</a> *psTime)</td></tr>
<tr class="memitem:ga6b82fa506fc6cf8d09b3816ace8fabf1"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga6b82fa506fc6cf8d09b3816ace8fabf1">umktime</a> (<a class="el" href="structt_time.html">tTime</a> *psTime)</td></tr>
<tr class="memitem:ga22fa13dc554cf317be1f6910e070b359"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga22fa13dc554cf317be1f6910e070b359">ustrtoul</a> (const char *pcStr, const char **ppcStrRet, int iBase)</td></tr>
<tr class="memitem:ga2a7ef5e22c99a2f20a0d0be873c0e806"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga2a7ef5e22c99a2f20a0d0be873c0e806">ustrnicmp</a> (const char *pcStr1, const char *pcStr2, int iCount)</td></tr>
<tr class="memitem:ga12db4770d8d7c76eb5c5f627b96d81c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga12db4770d8d7c76eb5c5f627b96d81c6">ustrncmp</a> (const char *pcStr1, const char *pcStr2, int iCount)</td></tr>
<tr class="memitem:ga85099260a1bb297c8695e4b319ce2ccf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ustdlib__api.html#ga85099260a1bb297c8695e4b319ce2ccf">usrand</a> (unsigned long ulSeed)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga06502f734fc4ece2a831fa0046c528bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulocaltime </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt_time.html">tTime</a> *&#160;</td>
          <td class="paramname"><em>psTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts from seconds to calendar date and time.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulTime</td><td>is the number of seconds. </td></tr>
    <tr><td class="paramname">psTime</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch) into the equivalent month, day, year, hours, minutes, and seconds representation.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a5728f0b62a5c92bc34f0a41c33278c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulocaltime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>tm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts from seconds to calendar date and time.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>is the number of seconds. </td></tr>
    <tr><td class="paramname">tm</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts a number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch) into the equivalent month, day, year, hours, minutes, and seconds representation.</p>
<dl class="section return"><dt>Returns:</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b82fa506fc6cf8d09b3816ace8fabf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long umktime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt_time.html">tTime</a> *&#160;</td>
          <td class="paramname"><em>psTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts calendar date and time to seconds.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">psTime</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts the date and time represented by the <em>psTime</em> structure pointer to the number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch).</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the calendar time and date as seconds. If the conversion was not possible then the function returns (unsigned long)(-1). </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf70d2ea7909ed1600710c2113c84907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t umktime </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts calendar date and time to seconds.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>is a pointer to the time structure that is filled in with the broken down date and time.</td></tr>
  </table>
  </dd>
</dl>
<p>This function converts the date and time represented by the <em>timeptr</em> structure pointer to the number of seconds since midnight GMT on January 1, 1970 (traditional Unix epoch).</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the calendar time and date as seconds. If the conversion was not possible then the function returns (uint32_t)(-1). </dd></dl>

</div>
</div>
<a class="anchor" id="ga04408b1c80a2190c4aad7b783b5af8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int urand </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a new (pseudo) random number</p>
<p>This function is very similar to the C library <code>rand()</code> function. It will generate a pseudo-random number sequence based on the seed value.</p>
<dl class="section return"><dt>Returns:</dt><dd>A pseudo-random number will be returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0523e2ba8a83e7cfc76be3caaf37b25a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple snprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcBuf</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">ulSize</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">pcString</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The function will copy at most <em>ulSize</em> - 1 characters into the buffer <em>pcBuf</em>. One space is reserved in the buffer for the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09b6644d4db11375176cb8cc8598c4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usnprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple snprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The function will copy at most <em>n</em> - 1 characters into the buffer <em>s</em>. One space is reserved in the buffer for the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d8940f65bf237f422d3a63312942a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple sprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcBuf</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">pcString</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The caller must ensure that the buffer <em>pcBuf</em> is large enough to hold the entire converted string, including the null termination character.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the count of characters that were written to the output buffer, not including the NULL termination character. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a47a964e1389c02987481ded1c48138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple sprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">...</td><td>are the optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>sprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeros instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The caller must ensure that the buffer <em>s</em> is large enough to hold the entire converted string, including the null termination character.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the count of characters that were written to the output buffer, not including the NULL termination character. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85099260a1bb297c8695e4b319ce2ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usrand </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSeed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the random number generator seed.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">ulSeed</td><td>is the new seed value to use for the random number generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>srand()</code> function. It will set the seed value used in the <code><a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand()</a></code> function.</p>
<dl class="section return"><dt>Returns:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gaaecc415a64e9bc2cce10f03eb7a6b753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usrand </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the random number generator seed.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>is the new seed value to use for the random number generator.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>srand()</code> function. It will set the seed value used in the <code><a class="el" href="group__ustdlib__api.html#ga04408b1c80a2190c4aad7b783b5af8d8">urand()</a></code> function.</p>
<dl class="section return"><dt>Returns:</dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="gacb9ef59ae11aae4f0169fb3dab34d2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrcasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcasecmp()</code> function. It compares two strings without regard to case. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>.</dd></dl>
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">pcStr2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcasecmp()</code> function. It compares two strings without regard to case. The comparison ends if a terminating NULL character is found in either string. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>pcStr1</em> is less than <em>pcStr2</em> and 1 if <em>pcStr1</em> is greater than <em>pcStr2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee3790eee84161a4ea17657fe464e8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcmp()</code> function. It compares two strings, taking case into account. The comparison ends if a terminating NULL character is found in either string. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>.</dd></dl>
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">pcStr2</td><td>points to the second string to be compared.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strcmp()</code> function. It compares two strings, taking case into account. The comparison ends if a terminating NULL character is found in either string. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>pcStr1</em> is less than <em>pcStr2</em> and 1 if <em>pcStr1</em> is greater than <em>pcStr2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bfaf237cc58e9d7cdc51f18e515d585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of a null-terminated string.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>is a pointer to the string whose length is to be found.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strlen()</code> function. It determines the length of the null-terminated string passed and returns this to the caller.</p>
<p>This implementation assumes that single byte character strings are passed and will return incorrect values if passed some UTF-8 strings.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the length of the string pointed to by <em>s</em>.</dd></dl>
<p>Retruns the length of a null-terminated string.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr</td><td>is a pointer to the string whose length is to be found.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strlen()</code> function. It determines the length of the null-terminated string passed and returns this to the caller.</p>
<p>This implementation assumes that single byte character strings are passed and will return incorrect values if passed some UTF-8 strings.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the length of the string pointed to by <em>pcStr</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0085d1d81c8d1570a12a02d3b6ffface"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrncasecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncasecmp()</code> function. It compares at most <em>n</em> characters of two strings without regard to case. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga12db4770d8d7c76eb5c5f627b96d81c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">pcStr2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">iCount</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncmp()</code> function. It compares at most <em>iCount</em> characters of two strings taking case into account. The comparison ends if a terminating NULL character is found in either string before <em>iCount</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>pcStr1</em> is less than <em>pcStr2</em> and 1 if <em>pcStr1</em> is greater than <em>pcStr2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gad21ed7429e68621153a72a7230a6a077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">s2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">n</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strncmp()</code> function. It compares at most <em>n</em> characters of two strings taking case into account. The comparison ends if a terminating NULL character is found in either string before <em>n</em> characters are compared. In this case, the int16_ter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>s1</em> is less than <em>s2</em> and 1 if <em>s1</em> is greater than <em>s2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gab49bf5cb17ebc95be3a294c502114ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ustrncpy </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>s2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a certain number of characters from one string to another.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the destination buffer into which characters are to be copied. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the string from which characters are to be copied. </td></tr>
    <tr><td class="paramname">n</td><td>is the number of characters to copy to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies at most <em>n</em> characters from the string pointed to by <em>s2</em> into the buffer pointed to by <em>s1</em>. If the end of <em>s2</em> is found before <em>n</em> characters have been copied, remaining characters in <em>s1</em> will be padded with zeroes until <em>n</em> characters have been written. Note that the destination string will only be NULL terminated if the number of characters to be copied is greater than the length of <em>s2</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <em>s1</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5ac4d97f96bc5f98116d1baa82f12b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* ustrncpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcDst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a certain number of characters from one string to another.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcDst</td><td>is a pointer to the destination buffer into which characters are to be copied. </td></tr>
    <tr><td class="paramname">pcSrc</td><td>is a pointer to the string from which characters are to be copied. </td></tr>
    <tr><td class="paramname">iNum</td><td>is the number of characters to copy to the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>This function copies at most <em>iNum</em> characters from the string pointed to by <em>pcSrc</em> into the buffer pointed to by <em>pcDst</em>. If the end of <em>pcSrc</em> is found before <em>iNum</em> characters have been copied, remaining characters in <em>pcDst</em> will be padded with zeroes until <em>iNum</em> characters have been written. Note that the destination string will only be NULL terminated if the number of characters to be copied is greater than the length of <em>pcSrc</em>.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns <em>pcDst</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a7ef5e22c99a2f20a0d0be873c0e806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ustrnicmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compares two strings without regard to case.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr1</td><td>points to the first string to be compared. </td></tr>
    <tr><td class="paramname">pcStr2</td><td>points to the second string to be compared. </td></tr>
    <tr><td class="paramname">iCount</td><td>is the maximum number of characters to compare.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strnicmp()</code> function. It compares at most <em>iCount</em> characters of two strings without regard to case. The comparison ends if a terminating NULL character is found in either string before <em>iCount</em> characters are compared. In this case, the shorter string is deemed the lesser.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns 0 if the two strings are equal, -1 if <em>pcStr1</em> is less than <em>pcStr2</em> and 1 if <em>pcStr1</em> is greater than <em>pcStr2</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadb47869995960c31c95f08a400882e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ustrstr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcHaystack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcNeedle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a substring within a string.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>is a pointer to the string that will be searched. </td></tr>
    <tr><td class="paramname">s2</td><td>is a pointer to the substring that is to be found within <em>s1</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strstr()</code> function. It scans a string for the first instance of a given substring and returns a pointer to that substring. If the substring cannot be found, a NULL pointer is returned.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns a pointer to the first occurrence of <em>s2</em> within <em>s1</em> or NULL if no match is found.</dd></dl>
<p>Finds a substring within a string.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcHaystack</td><td>is a pointer to the string that will be searched. </td></tr>
    <tr><td class="paramname">pcNeedle</td><td>is a pointer to the substring that is to be found within <em>pcHaystack</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strstr()</code> function. It scans a string for the first instance of a given substring and returns a pointer to that substring. If the substring cannot be found, a NULL pointer is returned.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns a pointer to the first occurrence of <em>pcNeedle</em> within <em>pcHaystack</em> or NULL if no match is found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c1f1d61220c492f777a3f25fd34df3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ustrtof </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a string into its floating-point equivalent.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the floating-point value. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the floating-point value in the string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtof()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into a floating-point value.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
<a class="anchor" id="ga22fa13dc554cf317be1f6910e070b359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ustrtoul </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ppcStrRet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iBase</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a string into its numeric equivalent.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcStr</td><td>is a pointer to the string containing the integer. </td></tr>
    <tr><td class="paramname">ppcStrRet</td><td>is a pointer that will be set to the first character past the integer in the string. </td></tr>
    <tr><td class="paramname">iBase</td><td>is the radix to use for the conversion; can be zero to auto-select the radix or between 2 and 16 to explicitly specify the radix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtoul()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into an integer value.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa6706f6aaf67c3370800e25b6ae1887d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long ustrtoul </td>
          <td>(</td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>nptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **restrict&#160;</td>
          <td class="paramname"><em>endptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a string into its numeric equivalent.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">nptr</td><td>is a pointer to the string containing the integer. </td></tr>
    <tr><td class="paramname">endptr</td><td>is a pointer that will be set to the first character past the integer in the string. </td></tr>
    <tr><td class="paramname">base</td><td>is the radix to use for the conversion; can be zero to auto-select the radix or between 2 and 16 to explicitly specify the radix.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>strtoul()</code> function. It scans a string for the first token (that is, non-white space) and converts the value at that location in the string into an integer value.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the result of the conversion. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3b713ceeb82516ed0373e7d4343d6e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>vaArgP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple vsnprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcBuf</td><td>points to the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">ulSize</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">pcString</td><td>is the format string. </td></tr>
    <tr><td class="paramname">vaArgP</td><td>is the list of optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vsnprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeroes instead of spaces.</p>
<p>The type of the arguments after <em>pcString</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The <em>ulSize</em> parameter limits the number of characters that will be stored in the buffer pointed to by <em>pcBuf</em> to prevent the possibility of a buffer overflow. The buffer size should be large enough to hold the expected converted output string, including the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4bfcb7b1819600ed85bee4da3cca530c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int uvsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *restrict&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *restrict&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A simple vsnprintf function supporting %c, %d, %p, %s, %u, %x, and %X.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>points to the buffer where the converted string is stored. </td></tr>
    <tr><td class="paramname">n</td><td>is the size of the buffer. </td></tr>
    <tr><td class="paramname">format</td><td>is the format string. </td></tr>
    <tr><td class="paramname">arg</td><td>is the list of optional arguments, which depend on the contents of the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is very similar to the C library <code>vsnprintf()</code> function. Only the following formatting characters are supported:</p>
<ul>
<li>%c to print a character</li>
<li>%d or %i to print a decimal value</li>
<li>%s to print a string</li>
<li>%u to print an unsigned decimal value</li>
<li>%x to print a hexadecimal value using lower case letters</li>
<li>%X to print a hexadecimal value using lower case letters (not upper case letters as would typically be used)</li>
<li>%p to print a pointer as a hexadecimal value</li>
<li>%% to print out a % character</li>
</ul>
<p>For %d, %i, %p, %s, %u, %x, and %X, an optional number may reside between the % and the format character, which specifies the minimum number of characters to use for that value; if preceded by a 0 then the extra characters will be filled with zeros instead of spaces. For example, <code>\%8d'' will use eight characters to print the decimal value with spaces added to reach eight;</code>%08d'' will use eight characters as well but will add zeroes instead of spaces.</p>
<p>The type of the arguments after <em>format</em> must match the requirements of the format string. For example, if an integer was passed where a string was expected, an error of some kind will most likely occur.</p>
<p>The <em>n</em> parameter limits the number of characters that will be stored in the buffer pointed to by <em>s</em> to prevent the possibility of a buffer overflow. The buffer size should be large enough to hold the expected converted output string, including the null termination character.</p>
<p>The function will return the number of characters that would be converted as if there were no limit on the buffer size. Therefore it is possible for the function to return a count that is greater than the specified buffer size. If this happens, it means that the output was truncated.</p>
<dl class="section return"><dt>Returns:</dt><dd>Returns the number of characters that were to be stored, not including the NULL termination character, regardless of space in the buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 22 2014 11:10:35 for Zigbee Module Examples by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
